function InitGlobals()
end

--CUSTOM_CODE
do
    local real = MarkGameStarted
    function MarkGameStarted()
        FogMaskEnableOff()
        FogEnableOff()
        InitCustomUI()
        StatusList()
        GetUnitX = GetUnitRealX
        GetUnitY = GetUnitRealY
        CreateBoss()
        CreateTestUnit()
        dummy1 = CreateDummy()
        dummy2 = CreateDummy()
        dummy3 = CreateDummy()
        posdummy = CreateDummy()
        impaleCasters = {dummy1, dummy2, dummy3}
        --BlzHideOriginFrames(true)
        CreateSlayer()
        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        globalX, globalY = GetUnitPosition(slayer)
        InitControlMouse()
        InitControlKeys()
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)


        --------------------
        CenterX = 1
        CenterY = 1
        Radius = 1800
        CreateBarrier()

        ClickBlocker = BlzCreateFrameByType("TEXT", "name", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
         CreateTextFrame(ClickBlocker, -0.1338, 0.6, 0.936020, 0, 1, "", 1)
            BlzFrameSetEnable(ClickBlocker, true)


        InitCameraScrollBar()
        InitDamageTrigger()
        --AttackTimer()

    end
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 14.05.2023 20:47
---
function SetGameCamera(preset)
    if preset == 40 then
        ResetToGameCamera( 1 )
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 60 then
        local t = {1480, 4800, 16, 310, 62, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, -250, true)
    end
    if preset == 80 then
        local t = {800, 4000, 16, 338.045, 30.0027917027, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 0 then
        local t = {3000, 5400, 16, 304, 90, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 20 then
        local t = {2400, 5400, 16, 304, 80, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
end

function SetCameraFields(t, d)
    SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, t[1], d)
    SetCameraField(CAMERA_FIELD_FARZ, t[2], d)
    SetCameraField(CAMERA_FIELD_NEARZ, t[3], d)
    SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, t[4], d)
    SetCameraField(CAMERA_FIELD_FIELD_OF_VIEW, t[5], d)
    SetCameraField(CAMERA_FIELD_ROTATION, t[6])
    SetCameraField(CAMERA_FIELD_ZOFFSET, t[7])
    --------------------
    SetCameraField(CAMERA_FIELD_ROLL, 0.0)
    SetCameraField(CAMERA_FIELD_LOCAL_PITCH, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_YAW, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_ROLL, 0)
end

function InitControlKeys()

    KeyTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_Q, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_V, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_E, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_SPACE, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_O, 0, true)
    TriggerAddCondition(KeyTrigger, Condition(ControlKeys))

    ------MOVING SYSTEM------
    orders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица текущих направлений
    futureOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица будущих направлений, нужно хранить, чтобы можно было быстро перемещаться в противоположную сторону
    additionalOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --нужна для хранения направлений, заданных кратковременными нажатиями, и не попавших в основные из-за тика таймера

    Apressed = false
    Wpressed = false
    Spressed = false
    Dpressed = false

    ButtonPressedTrigger = CreateTrigger()
    ButtonReleasedTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_A, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_A, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_W, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_W, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_S, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_S, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_D, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_D, 0, false)

    TriggerAddCondition(ButtonPressedTrigger, Condition(ButtonPressed))
    TriggerAddCondition(ButtonReleasedTrigger, Condition(ButtonReleased))
    InitWalkTimer()
end
function InitWalkTimer()
    local acidCounter = 0
    walkTimer = CreateTimer()
    TimerStart(walkTimer, 1/16, true, function()
        local ux, uy = GetUnitPosition(slayer)
        if (Apressed or Wpressed or Dpressed or Spressed) and not Chaining then --and not (Apressed and Dpressed) and not (Wpressed and Spressed))
            --local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            --local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            if orders.Xm == 300 and orders.Xp == 300 then
                if not Apressed then
                    orders.Xm = 0
                end
                if not Dpressed then
                    orders.Xp = 0
                end
            end
            if orders.Ym == 300 and orders.Yp == 300 then
                if not Spressed then
                    orders.Ym = 0
                end
                if not Wpressed then
                    orders.Yp = 0
                end
            end

            --local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            if not sawing then
                if not CageOn then
                    IssuePointOrder(slayer, "move", x, y)
                    FixCursor(ux, uy)
                elseif SlayerInsideCage then
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if not IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                else
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                end
            end
            --print(orders.Xm.." "..orders.Xp.." "..orders.Ym.." "..orders.Yp.." "..x.." "..y.." "..ux.." "..uy)
        elseif --(not Apressed and not Wpressed and not Dpressed and not Spressed) and
        (additionalOrders.Xm ~= 0 or additionalOrders.Xp ~= 0 or additionalOrders.Ym ~= 0 or additionalOrders.Yp ~= 0) and not Chaining then
            --print("additional condition")
            for k, v in pairs(additionalOrders) do
                if v ~= 0 then
                    orders[k] = v
                    additionalOrders[k] = 0
                end
            end
            local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            --local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            if not sawing then
                if not CageOn then
                    IssuePointOrder(slayer, "move", x, y)
                    FixCursor(ux, uy)
                elseif SlayerInsideCage then
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if not IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                else
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                end
            end
        else
            orders.Xm = 0
            orders.Yp = 0
            orders.Xp = 0
            orders.Ym = 0
            IssueImmediateOrder(slayer, "stop")
        end
        if acidGlobal then
            local sharp = #puddles
            for p = 1, sharp do
                if IsPointInCircle(ux, uy, puddles[p].x, puddles[p].y, 90) then
                    acidCounter = acidCounter + 1
                    if acidCounter >= 2 then
                        GotDamage("acid")
                        acidCounter = 0
                    end
                    break
                end
            end
        end
    end)
end

function ButtonPressed()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = true
        if Dpressed == false then
            orders.Xm = 300
            additionalOrders.Xm = 300
        else
            futureOrders.Xm = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = true
        if Spressed == false then
            orders.Yp = 300
            additionalOrders.Yp = 300
        else
            futureOrders.Yp = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = true
        if Wpressed == false then
            orders.Ym = 300
            additionalOrders.Ym = 300
        else
            futureOrders.Ym = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = true
        if Apressed == false then
            orders.Xp = 300
            additionalOrders.Xp = 300
        else
            futureOrders.Xp = 300
        end
    end
end

function ButtonReleased()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = false
        orders.Xm = 0
        if futureOrders.Xp ~= 0 then
            orders.Xp = futureOrders.Xp
            futureOrders.Xp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = false
        orders.Yp = 0
        if futureOrders.Ym ~= 0 then
            orders.Ym = futureOrders.Ym
            futureOrders.Ym = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = false
        orders.Ym = 0
        if futureOrders.Yp ~= 0 then
            orders.Yp = futureOrders.Yp
            futureOrders.Yp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = false
        orders.Xp = 0
        if futureOrders.Xm ~= 0 then
            orders.Xm = futureOrders.Xm
            futureOrders.Xm = 0
        end
    end
end


function ControlKeys()
    if BlzGetTriggerPlayerKey() == OSKEY_Q then
        print("Q")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        TimerStart(CreateTimer(), 2, true, function()
            FireBalls()
        end)
    end
    if BlzGetTriggerPlayerKey() == OSKEY_E then
        --print("E")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        Sawing()
    end
    if BlzGetTriggerPlayerKey() == OSKEY_V then
        CameraSetFocalDistance(0)
        print("V")

        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        --ThrowStones(15)
        --TripleImpale(35)
        --CreateTestUnit()
        --Laser()
        --Acid(30)
        --Cage(500, 5)
        --CorpseBombs()
        BeetleLaunch()
    end

    if BlzGetTriggerPlayerKey() == OSKEY_SPACE then
        print("SPACE")
        Dash()
    end
end

function TurnKeyTriggers(off)
    if off then
        DisableTrigger(KeyTrigger)
        DisableTrigger(ButtonPressedTrigger)
        DisableTrigger(ButtonReleasedTrigger)
    else
        EnableTrigger(KeyTrigger)
        EnableTrigger(ButtonPressedTrigger)
        EnableTrigger(ButtonReleasedTrigger)
    end
end
function InitControlMouse()
    MouseTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(MouseTrigger, Player(0), EVENT_PLAYER_MOUSE_MOVE)

    TriggerAddCondition(MouseTrigger, Condition(ControlMouse))

  ClickTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(ClickTrigger, Player(0), EVENT_PLAYER_MOUSE_DOWN)
    TriggerAddCondition(ClickTrigger, Condition(Clicker))


WheelTrigger = CreateTrigger()
    BlzTriggerRegisterFrameEvent(WheelTrigger, InfoBackground, FRAMEEVENT_MOUSE_WHEEL)
    TriggerAddAction(trigger, function()
        print("wheel")
    end)
  ClickReleaseTrigger = CreateTrigger()
   TriggerRegisterPlayerEvent(ClickReleaseTrigger, Player(0), EVENT_PLAYER_MOUSE_UP)
   TriggerAddCondition(ClickReleaseTrigger, Condition(Releaser))

    chainMarker = false
    rmbpressed = false

end

function ControlMouse()
    SetUnitFaceToCursor()
end

function CancelClick()
    print("world click")
    ForceUICancelBJ(Player(0))
end

function Wheel()
    print("Wheel")
end

function Clicker()
    if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) and not sawing then
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_LEFT then
            MakeShot(BlzGetTriggerPlayerMouseX(), BlzGetTriggerPlayerMouseY())
        end
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_RIGHT then
            --local eff = AddSpecialEffect("models\\greencircle", BlzGetTriggerPlayerMouseX(), BlzGetTriggerPlayerMouseY())
            --table.insert(slayerEffects, eff)
            rmbpressed = true
            FindChainTarget()
        end
    end
end

function Releaser()
    if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) then
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_RIGHT then
            rmbpressed = false
            ChainHook()
        end
    end
end


function InitCameraScrollBar()
    -- create a vertical slider by inheriting from a Scrollbar. It will use esc menu textures
    local sliderFrame = BlzCreateFrameByType( "SLIDER", "TestSlider", BlzGetFrameByName("ConsoleUIBackdrop", 0), "QuestMainListScrollBar", 0 )
    -- clear the inherited attachment
    BlzFrameClearAllPoints(sliderFrame)
    -- set pos and size
    BlzFrameSetLevel(sliderFrame, 3)
    BlzFrameSetAbsPoint(sliderFrame, FRAMEPOINT_CENTER, 0.92, 0.30 )
    BlzFrameSetSize(sliderFrame, 0.014, 0.1 )
    -- define the area the user can choose from
    BlzFrameSetMinMaxValue(sliderFrame, 0, 80)
    -- how accurate the user can choose value
    BlzFrameSetStepSize(sliderFrame, 20)
    BlzFrameSetValue(sliderFrame, 40)

    local trigger = CreateTrigger()

    -- register the Slider Event
    BlzTriggerRegisterFrameEvent(trigger, sliderFrame, FRAMEEVENT_SLIDER_VALUE_CHANGED)

    -- this happens when the Slider is pushed
    TriggerAddAction(trigger, function()
        local frame = BlzGetTriggerFrame()
        --print(BlzFrameGetName(frame), "new Value", BlzGetTriggerFrameValue())
        SetGameCamera(BlzGetTriggerFrameValue())

    end)

    -- scorllable with mousewheel
    local triggerWheel = CreateTrigger()
    -- register the Mouse Wheel Event for the Slider
    BlzTriggerRegisterFrameEvent(triggerWheel, sliderFrame, FRAMEEVENT_MOUSE_WHEEL)
    -- this happens when the Mouse wheel is rolled while it points at the slider
    TriggerAddAction(triggerWheel, function()

        -- BlzGetTriggerFrameValue() tells us in which direction the wheel was rolled
        local add
        if BlzGetTriggerFrameValue() > 0 then
            add = 20
        else
            add = -20
        end

        -- the scrolling should only affect the triggering Player
        if GetLocalPlayer() == GetTriggerPlayer() then
            BlzFrameSetValue(sliderFrame, BlzFrameGetValue(sliderFrame) + add)
        end
    end)
end
globalCursorX = 0
globalCursorY = 0

globalCursorXInit = 0
globalCursorYInit = 0


function SetUnitFaceToCursor()
    globalCursorX = BlzGetTriggerPlayerMouseX()
    globalCursorY = BlzGetTriggerPlayerMouseY()

    globalCursorXInit, globalCursorYInit = globalCursorX, globalCursorY

    local ux, uy = GetUnitPosition(slayer)
    globalX, globalY = ux, uy
    --local angle = CalculateAngle(ux, uy, x, y)
    --SetUnitFacing(slayer, angle*180/math.pi)
    --SetUnitPositionWithFacing(slayer, ux, uy, angle)
    local posx, posy = FindCenterRayIntersection(ux, uy, globalCursorX, globalCursorY, 256)
    SetUnitPosition(posdummy, posx, posy)
end


function FixCursor(localX, localY)
    local deltaX = localX - globalX
    local deltaY = localY - globalY

    if deltaX ~= 0 or deltaY ~= 0 then
        globalCursorX = globalCursorXInit + deltaX
        globalCursorY = globalCursorYInit + deltaY
    end

    local posx, posy = FindCenterRayIntersection(localX, localY, globalCursorX, globalCursorY, 256)
    SetUnitPosition(posdummy, posx, posy)
end
function _(code)
    return FourCC(code)
end

function HideDefaultUI()
    print("Hide")
    TimerStart(CreateTimer(), 1, false, function()
        --local info_bar = BlzFrameGetChild(ORIGIN_FRAME_GAME_UI, 1)
        local gameui = BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
        BlzFrameSetVisible(BlzFrameGetChild(gameui, 1), false)
        BlzFrameSetAbsPoint(BlzGetFrameByName("ConsoleUIBackdrop", 0), FRAMEPOINT_TOPRIGHT, 0, 0)
        for i = 0, 11 do
            BlzFrameSetVisible(BlzGetFrameByName("CommandButton_" .. i, 0), false)
        end
        BlzHideOriginFrames(true)
        BlzFrameSetScale(BlzFrameGetChild(BlzGetFrameByName("ConsoleUI", 0), 5), 0.001)

    end)
end

function GetUnitPosition(u)
    local x = GetUnitX(u)
    local y = GetUnitY(u)
    return x, y
end

function SetUnitPositionWithFacing(u, x, y, angle)
    SetUnitX(u, x)
    SetUnitY(u, y)
    SetUnitFacing(u, angle*180/math.pi)
end


function CreateTextFrame(frame, topleftX, topleftY, botrightX, botrightY, level, text, scale)
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_TOPLEFT, topleftX, topleftY)
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_BOTTOMRIGHT, botrightX, botrightY)
    BlzFrameSetLevel(frame, level)
    BlzFrameSetText(frame, text)
    BlzFrameSetEnable(frame, false)
    BlzFrameSetScale(frame, scale)
    BlzFrameSetTextAlignment(frame, TEXT_JUSTIFY_CENTER, TEXT_JUSTIFY_MIDDLE)
end

function FindClosestUnit(units, x, y)
    local closestUnit = nil
    local closestDistance = math.huge
    for i, unit in ipairs(units) do
        local unitX, unitY = GetUnitPosition(unit)
        local distance = CalculateDistance(unitX, unitY, x, y)
        if distance < closestDistance then
            closestUnit = unit
            closestDistance = distance
        end
    end
    return closestUnit
end

function Shuffle (arr)
    for i = 1, #arr - 1 do
        local j = math.random (i, #arr)
        arr [i], arr [j] = arr [j], arr [i]
    end
end
function CalculateAngleAndDistance(x1, y1, x2, y2)
    --возвращает угол в радианах и расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return angle, distance
end

function CalculateAngle(x1, y1, x2, y2)
    --возвращает угол в радианах между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    return angle
end

function CalculateDistance(x1, y1, x2, y2)
    --возвращает расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return distance
end

function FindIntersection(x1, y1, x2, y2)
    --возвращает точку пересечения луча, проходящего через две произвольных точки внутри окружности, с этой окружностью
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx^2 + dy^2
    local b = 2 * (dx * (x1 - CenterX) + dy * (y1 - CenterY))
    local c = CenterX^2 + CenterY^2 + x1^2 + y1^2 - 2 * (CenterX * x1 + CenterY * y1) - Radius^2
    local bb4ac = b^2 - 4 * a * c
    if bb4ac < 0 then
        return nil
    end
    local mu = (-b + math.sqrt(bb4ac)) / (2 * a)
    local ix1 = x1 + mu * dx
    local iy1 = y1 + mu * dy
    mu = (-b - math.sqrt(bb4ac)) / (2 * a)
    local ix2 = x1 + mu*dx
    local iy2 = y1 + mu*dy

    if (ix1-x1)*(ix2-x1) > 0 or (iy1-y1)*(iy2-y1) > 0 then
        return nil
    end

    return ix1, iy1
end

function FindCenterRayIntersection(x1, y1, x2, y2, radius)
    --возвращает точку пересечения луча, проходящего через центр окружности и произвольную точку, с этой окружностью
    local angle = CalculateAngle(x1, y1, x2, y2)
    local x3 = x1 + radius * math.cos(angle)
    local y3 = y1 + radius * math.sin(angle)
    return x3, y3
end

function GetPointsOnLine(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)
    for i = 1, steps do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        table.insert(points, {x = x, y = y})
    end
    table.insert(points, {x = x2, y = y2})
    return points
end

function GetPointsOnLineWithRotation(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки, а также рандомные значения вращения
    --с pitch возникает какой-то баг, если задавать через SetPitch
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)

    local startYaw = math.random(-math.pi, math.pi)
    local endYaw = math.random(-math.pi, math.pi)
    local startPitch = math.random(-math.pi, math.pi)
    local endPitch = math.random(-math.pi, math.pi)
    local startRoll = math.random(-math.pi, math.pi)
    local endRoll = math.random(-math.pi, math.pi)

    for i = 1, steps+1 do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        local yaw = startYaw + (endYaw - startYaw) * t
        local pitch = startPitch + (endPitch - startPitch) * t
        local roll = startRoll + (endRoll - startRoll) * t
        table.insert(points, {x = x, y = y, yaw = yaw, pitch = pitch, roll = roll})
    end

    table.insert(points, {x = x2, y = y2, yaw = endYaw, pitch = endPitch, roll = endRoll})
    return points
end

function GetPointOnLine(x1, y1, x2, y2, d)
    --возвращает точку на луче, удалённую от начальной точки на расстояние d
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    --local dist = CalculateDistance(x1, y1, x2, y2)
    local t = d / dist
    local x = x1 + dx * t
    local y = y1 + dy * t
    return x, y
end


function RayCircleIntersection(x1, y1, x2, y2, x3, y3, r)
    --возвращает первую точку пересечения луча с окружностью. Иначе возвращает nil
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx * dx + dy * dy
    local b = 2 * (dx * (x1 - x3) + dy * (y1 - y3))
    local c = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3) - r * r
    local disc = b * b - 4 * a * c
    if disc < 0 then
        return nil
    else
        local t1 = (-b + math.sqrt(disc)) / (2 * a)
        local t2 = (-b - math.sqrt(disc)) / (2 * a)
        if t1 >= 0 and (t2 < 0 or t1 < t2) then
            return x1 + t1 * dx, y1 + t1 * dy
        elseif t2 >= 0 then
            return x1 + t2 * dx, y1 + t2 * dy
        else
            return nil
        end
    end
end

function IsPointInCircle(x1, y1, x2, y2, r)
    --возвращает true, если точка находится в окружности с центром (x2, y2) и радиусом r
    local distance = CalculateDistance(x1, y1, x2, y2, r)
    return distance < r
end

function QuadraticBezier(z1, z2, z3, t)
    --возвращает значение координаты на кривой безье
    local u = 1 - t
    local tt = t * t
    local uu = u * u
    local z = uu * z1 + 2 * u * t * z2 + tt * z3
    return z
end

function ComputePath(x1, y1, z1, x3, y3, z3, z2, d)
    --возвращает таблицу значений координат полёта снаряда
    local dx = x3 - x1
    local dy = y3 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local n = math.ceil(distance / d)

    local path = {}

    for i = 0, n do
        local t = i / n

        local x = x1 + t * (x3 - x1)
        local y = y1 + t * (y3 - y1)
        local z = QuadraticBezier(z1,z2,z3,t)

        table.insert(path, {x = x, y = y, z = z})
    end

    return path
end

function ComputePathWithRotation(x1, y1, z1, x3, y3, z3, z2, d)
    local dx = x3 - x1
    local dy = y3 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local n = math.ceil(distance / d)

    local path = {}

    local startYaw = math.random(-math.pi, math.pi)
    local endYaw = math.random(-math.pi, math.pi)
    local startPitch = math.random(-math.pi, math.pi)
    local endPitch = math.random(-math.pi, math.pi)
    local startRoll = math.random(-math.pi, math.pi)
    local endRoll = math.random(-math.pi, math.pi)

    for i = 0, n do
        local t = i / n

        local x = x1 + t * (x3 - x1)
        local y = y1 + t * (y3 - y1)
        local z = QuadraticBezier(z1,z2,z3,t)

        local yaw = startYaw + (endYaw - startYaw) * t
        local pitch = startPitch + (endPitch - startPitch) * t
        local roll = startRoll + (endRoll - startRoll) * t

        table.insert(path, {x = x, y = y, z = z, yaw = yaw, pitch = pitch, roll = roll})
    end

    return path
end

function RandomPointInCircle(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return {x, y}
end

function GetRandomPointOnCircle(centerX, centerY, radius)
    --возвращает случайную точку на окружности
    local angle = math.random() * math.pi * 2
    local x = centerX + radius * math.cos(angle)
    local y = centerY + radius * math.sin(angle)
    return x, y
end

function GetOppositePointOnCircle(centerX, centerY, pointX, pointY)
    --возвращает диаметрально противоположную точку на окружности
    local dx = centerX - pointX
    local dy = centerY - pointY
    local oppositeX = centerX + dx
    local oppositeY = centerY + dy
    return oppositeX, oppositeY
end

function RandomPointInCircleXY(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return x, y
end

function IsCirclesIntersect(x1, y1, r1, x2, y2, r2)
    --возвращает true если две окржуности пересекаются
    local dx = x2 - x1
    local dy = y2 - y1
    local distance = math.sqrt(dx * dx + dy * dy)
    return distance < r1 + r2
end

function RotatePoints(centerX, centerY, radius, step)
    --возвращает таблицу значений x,y для вращения четырёх точек по окружности
    local points = {{},{},{},{}}
    for angle = 0, 360, step do
        local radians = math.rad(angle)
        for i = 1, 4 do
            local x = centerX + radius * math.cos(radians + math.pi/2 * (i-1))
            local y = centerY + radius * math.sin(radians + math.pi/2 * (i-1))
            table.insert(points[i], {x, y})
        end
    end
    return points
end

function RotateDiameter(pointsDiameter, centerX, centerY, angle)
    --поворачивает диаметр на угол angle
    local newPoints = {}
    for i, point in ipairs(pointsDiameter) do
        local x = point.x - centerX
        local y = point.y - centerY
        local newX = x * math.cos(angle) + y * math.sin(angle)
        local newY = -x * math.sin(angle) + y * math.cos(angle)
        table.insert(newPoints, {x = newX + centerX, y = newY + centerY})
    end
    return newPoints
end

function GetPerpendicularDiameter(radius, x1, y1, x2, y2)
    --возвращает координаты конечных точек диаметра перпендикулярного заданному диаметру
    local midX = (x1 + x2) / 2
    local midY = (y1 + y2) / 2
    local slope = (y2 - y1) / (x2 - x1)
    local perpSlope = -1 / slope
    local x3 = midX + math.sqrt(radius^2 / (1 + perpSlope^2))
    local y3 = perpSlope * (x3 - midX) + midY
    local x4 = midX - math.sqrt(radius^2 / (1 + perpSlope^2))
    local y4 = perpSlope * (x4 - midX) + midY
    return x3, y3, x4, y4
end

function MovePoint(x1, y1, x2, y2, x3, y3)
    --бред
    local angle = CalculateAngleAndDistance(x1, y1, x2, y2)
    local dist = CalculateDistance(x1, y1, x3, y3)
    local newX3 = x1 + dist * math.cos(angle)
    local newY3 = y1 + dist * math.sin(angle)
    return newX3, newY3
end


function GetPointsOnCircle(centerX, centerY, radius, interval)
    --возвращает таблицу точек на окружности
    local points = {}
    local numPoints = math.floor(2 * math.pi / interval)
    print(numPoints)
    for i = 1, numPoints do
        local angle = interval * (i - 1)
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(points, {x = x, y = y})
    end
    return points
end

function HexagonPoints(centerX, centerY, radius)
    --возвращает вершины шестиугольника
    local points = {}
    for i = 1, 6 do
        local angle = 2 * math.pi / 6 * (i - 1)
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(points, x)
        table.insert(points, y)
    end
    return points
end

function GetHexagonPoints(centerX, centerY, radius, d)
    --возвращает таблицу точек на контуре шестиугольника
    local points = HexagonPoints(centerX, centerY, radius)
    local allPoints = {}
    for i = 1, #points - 2, 2 do
        local x1 = points[i]
        local y1 = points[i + 1]
        local x2 = points[i + 2]
        local y2 = points[i + 3]
        local sidePoints = GetPointsOnLine(x1, y1, x2, y2, d)
        table.remove(sidePoints, #sidePoints)
        for _, point in ipairs(sidePoints) do
            table.insert(allPoints, point)
        end
    end
    local x1 = points[#points - 1]
    local y1 = points[#points]
    local x2 = points[1]
    local y2 = points[2]
    local sidePoints = GetPointsOnLine(x1, y1, x2, y2, d)
    table.remove(sidePoints, #sidePoints)
    for _, point in ipairs(sidePoints) do
        table.insert(allPoints, point)
    end
    return allPoints
end

function IsPointInHexagon(x, y, hexagonPoints)
    --проверяет наличие точки в пространстве, ограниченном контуром шестиугольника
    local intersections = 0
    for i = 1, #hexagonPoints - 1 do
        local x1 = hexagonPoints[i].x
        local y1 = hexagonPoints[i].y
        local x2 = hexagonPoints[i + 1].x
        local y2 = hexagonPoints[i + 1].y
        if ((y1 > y) ~= (y2 > y)) and (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) then
            intersections = intersections + 1
        end
    end
    local x1 = hexagonPoints[#hexagonPoints].x
    local y1 = hexagonPoints[#hexagonPoints].y
    local x2 = hexagonPoints[1].x
    local y2 = hexagonPoints[1].y
    if ((y1 > y) ~= (y2 > y)) and (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) then
        intersections = intersections + 1
    end
    return intersections % 2 == 1
end
function PlayCage()
    PlaySound("Buildings/Undead/Graveyard/GraveYardWhat1.flac")
end

function PlayAcid()
    PlaySound("Units/Undead/HeroCryptLord/NerubianCryptLordYesAttack2.flac")
end

function PlayHit()
    PlaySound("sounds\\hit")
end

function PlayScream()
    PlaySound("Units/Undead/Shade/ShadeDeath1")
end

function PlaySawFleshSound()
    PlaySound("sounds\\sawflesh.flac")
end

function PlayDashSound()
    PlaySound("Abilities/Spells/NightElf/Blink/BlinkBirth1.flac")
end

function PlayImpaleSound()
    PlaySound("Abilities/Spells/Undead/Impale/ImpaleHit.flac")
end

function PlayBrokenChain()
    PlaySound("Units/Human/SteamTank/SteamTankAttack1")
end

function PlayChain()
    PlaySound("sounds\\chain.flac")
end

function PlayStoneSound1(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound2(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath2.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound3(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath3.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSoundMain(x, y)
    local t = {PlayStoneSound1, PlayStoneSound2, PlayStoneSound3}
    local n = math.random(#t)
    t[n](x, y)
end

function PlayPainSound1()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound2()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound3()
    local snd = CreateSound("sounds\\Pain3",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound4()
    local snd = CreateSound("sounds\\Pain4",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound5()
    local snd = CreateSound("sounds\\Pain5",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSoundMain()
    local foos = {PlayPainSound1, PlayPainSound2, PlayPainSound3, PlayPainSound4, PlayPainSound5}
    local n = math.random(#foos)
    foos[n]()
end

function PlayImpaleMarkerSound(x, y)
    local snd = CreateSound("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 10)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end
barrier = {}

function CreateBarrier()
    local points = GetPointsOnCircle(CenterX, CenterY, Radius, 2 * math.pi / 180)

    for i = 1, #points do
        local angle = CalculateAngle(points[i].x, points[i].y, CenterX, CenterY) + math.pi / 2
        local eff = AddSpecialEffect("models\\barrier", points[i].x, points[i].y)
        BlzSetSpecialEffectScale(eff, 2)
        --BlzSetSpecialEffectZ(eff, 300)
        BlzSetSpecialEffectYaw(eff, angle)
        --BlzSetSpecialEffectScale(eff, 2)
        --BlzSetSpecialEffectZ(eff, 400)
        table.insert(barrier, eff)
    end
end
function AttackTimer()
    --эти атаки не могут быть одновременно друг с другом: {глыбы, файрболлы, крест жуков}, {крест жуков, импейл}
    --
    math.randomseed(os.time())
    globalAttackTimer = CreateTimer()
    TimerStart(globalAttackTimer, 10, true, function()
        local rand = math.random()
        if rand < 0.2 then
            Bugs()
        elseif rand < 0.5 then
            TripleImpale(math.random(30, 35))
        else
            ThrowStones(5)
        end
    end)
end
function GotDamage(type)
    if not BlzIsUnitInvulnerable(slayer) then
        print("got damage")
        PlayPainSoundMain()

        if type == "mechanical" then
            CrackedGlassEffect()
        end

        if type == "impale" then
            CrackedGlassEffect()
        end

        if type == "fire" then
            MaskEffect("backdrops\\VignetteFire.dds", 100, 100, 100)
        end

        if type == "acid" then
            MaskEffect("backdrops\\VignettePoison.dds", 100, 100, 100)
        end

        if type == "bite" then
            MaskEffect("backdrops\\VignetteDamage.dds", 75, 10, 10)
        end

        if type == "blood" then
            CameraSetEQNoiseForPlayer( Player(0), 30.00 )
            local t = CreateTimer()
            TimerStart(t, 0.2, false, function()
                CameraClearNoiseForPlayer( Player(0) )
                DestroyTimer(t)
            end)
            MaskEffect("backdrops\\blood1.dds")
        end
    end
end

function BloodFrame()
    local randomX = math.random(10, 70) / 100
    local randomY = math.random(20, 50) / 100
    local randomS = math.random(20, 50) / 100
    local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
    BlzFrameSetLevel(Mask,4)
    BlzFrameSetAbsPoint(Mask, FRAMEPOINT_CENTER, randomX, randomY)
    BlzFrameSetSize(Mask, randomS, randomS)
    BlzFrameSetTexture(Mask, "backdrops\\blood5", 0, true)
    BlzFrameSetAlpha(Mask, 255)
    local alpha = 255
    TimerStart(CreateTimer(), 1/32, true, function()
        alpha = alpha - 4
        if alpha <=0 then
            BlzFrameSetAlpha(Mask, 0)
            BlzDestroyFrame(Mask)
            DestroyTimer(GetExpiredTimer())
        else
            BlzFrameSetAlpha(Mask, alpha)
        end
    end)
end

function MaskEffect(path, red, green, blue)
    DisplayCineFilter(false)
    CinematicFilterGenericBJ( 5.00, BLEND_MODE_BLEND, path, red, green, blue, 0.00, 0, 0, 0, 100.00 )
end

function CrackedGlassEffect()
    CameraSetEQNoiseForPlayer( Player(0), 30.00 )
    local t = CreateTimer()
    TimerStart(t, 0.2, false, function()
        CameraClearNoiseForPlayer( Player(0) )
        DestroyTimer(t)
    end)

    local randx = math.random() * 0.9
    local randy = math.random() * 0.5
    local randAnim = math.random(0, 4)
    local randScale = math.random() * 1.25 + 0.75

    ----------
    local crack = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0), "", 0)
    --
    BlzFrameSetAbsPoint(crack, FRAMEPOINT_CENTER, randx, randy)
    BlzFrameSetLevel(crack, 4)
    BlzFrameSetSize(crack, 0.01, 0.01)
    BlzFrameSetModel(crack, "sprites\\brokenglass", 1)
    BlzFrameSetScale(crack, randScale)
    BlzFrameSetSpriteAnimate(crack, randAnim, 2)
    BlzFrameSetAlpha(crack, 255)
    PlayHit()

    local t2 = CreateTimer()
    local alpha = 255
    TimerStart(t2, 1/16, true, function()
        alpha = alpha - 1
        if alpha <= 0 then
            BlzFrameSetAlpha(crack, 0)
            BlzDestroyFrame(crack)
            DestroyTimer(t)
        else
            BlzFrameSetAlpha(crack, alpha)
        end
    end)
end


function ControlDmg(unit)
    SetUnitState(unit, UNIT_STATE_LIFE, GetUnitState(unit, UNIT_STATE_LIFE) - 25)
end

function CheckFireballDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 50) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("fire")
    end
    return
end

function CheckCorpseBombDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 95) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("mechanical")
    end
    return
end

function CheckCorpseFireworksDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("blood")
    end
    return
end


function CheckStoneDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 32, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("mechanical")
        return true
    else
        return false
    end
end

function CheckBeetleDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 32, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("bite")
        return true
    else
        return false
    end
end

function BeetlePeriodic()
    local t = CreateTimer()
    TimerStart(t, 0.5, true, function()
        if beetleAtached then
            GotDamage("bite")
        else
            DestroyTimer(t)
        end
        print(beetleAtached)
    end)
end

function InitDamageTrigger()
    local DamageTrigger = CreateTrigger()
    --TriggerRegisterUnitEvent(DamageTrigger, impaleCasters[1], EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    TriggerRegisterPlayerUnitEvent(DamageTrigger, Player(2), EVENT_PLAYER_UNIT_SPELL_ENDCAST, null)
    TriggerAddCondition(DamageTrigger, Condition(ResetAfterDamage))

end

function ResetAfterDamage()
    SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
    SetUnitState(slayer, UNIT_STATE_LIFE, GetUnitState(slayer, UNIT_STATE_MAX_LIFE))
    --GotDamage()
    if GetTriggerUnit() == impaleCasters[1] and (GetUnitAbilityLevel(slayer, _('BUim')) > 0) then
        GotDamage("impale")
    end
end




function StatusList()
    Stage = 1 --текущая стадия
    ------
    CageOn = false --существует ли клетка на карте
    SlayerInsideCage = false --герой в клетке
    hexPoints = {} --координаты клетки
    ------
    cooldown = false --кулдаун ракетницы

    Chaining = false --юзает хук
    chaincooldown = false --кулдаун хука
    slayerEffects = {} --таблица с эффектами для поиска цели хука
    slayerEffectsRed = {}
    targetEffects = {}

    acidGlobal = false --кислота на карте
    puddles = {} --координаты луж кислоты
    puddlesEffects = {} --таблица эффектов с кислотой

    beetleAtached = false --жук прицепился к герою
    beetleAttach = nil --глоаблка для хранения эффекта жука
    beetleHP = 3 --хп прицепившегося жука
    beetleFrame = nil --глобалка для фрейма с жуком

    sawing = false --герой пилит

    dashing = false --герой в рывке



end
RealGetUnitX = GetUnitX
RealGetUnitY = GetUnitY


function GetUnitRealX(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitX(unit) - 16. end
    end

    return RealGetUnitX(unit)
end

function GetUnitRealY(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitY(unit) - 16. end
    end

    return RealGetUnitY(unit)
end
function HPBar()
    local bar = BlzCreateFrameByType("STATUSBAR", "", BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0), "", 0)
    BlzFrameSetAbsPoint(bar, FRAMEPOINT_CENTER, 0.4, 0.57)
    -- Screen Size does not matter but has to be there
    BlzFrameSetSize(bar, 0.00001, 0.00001)

    -- Models don't care about Frame Size, But world Object Models are huge . To use them in the UI one has to scale them down alot.
    BlzFrameSetScale(bar, 1)

    --BlzFrameSetModel(bar, "ui/feedback/cooldown/ui-cooldown-indicator.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/XpBar/XpBarConsole.mdx", 0)
    BlzFrameSetModel(bar, "sprites/testbar.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/buildprogressbar/buildprogressbar.mdx", 0)
    --BlzFrameSetMinMaxValue(bar, 0, 100)
    BlzFrameSetValue(bar, 90)
    local i = 0
    TimerStart(CreateTimer(), 4, true, function()
        BlzFrameSetModel(bar, "sprites/testbar1.mdx", 0)
        --BlzFrameSetValue(bar, i)
        --i = i + 1
        --if i > 100 then
            --i = 0
        --end
        --i = GetRandomInt(0, 100)
        --print(BlzFrameGetValue(bar))
    end)
end
function InitCustomUI()
    HideDefaultUI()
    HPBar()
end
creeps = {}

function CreateTestUnit()
    local testUnit = CreateUnit(Player(1), _('uaco'), math.random(0, 800), math.random(0, 800), bj_UNIT_FACING)
    SetUnitPathing(testUnit, false)
    table.insert(creeps, testUnit)
end

function CreateDummy()
    local d = CreateUnit(Player(2), _('Dmmy'), -1500, -1500, bj_UNIT_FACING)
    SetHeroLevel(d, 10, false)
    SelectHeroSkill(d, _('AUim'))
    SetUnitInvulnerable(d, true)
    return d
end
function Acid(numb, duration)
    local points = {}
    for i = 1, numb do
        table.insert(points, RandomPointInCircle(CenterX, CenterY, Radius))
    end

    --local acid = AddSpecialEffect("models\\puddle", 400, 400)
    --BlzSetSpecialEffectScale(acid, 1.5)
    local startX, startY = GetUnitPosition(boss)
    local t = CreateTimer()
    local a = 1
    SetUnitAnimationByIndex(boss, 7)
    TimerStart(t, 1/32, true, function()
        AcidBomb(startX, startY, points[a][1], points[a][2])
        a=a+1
        if a > #points then
            PauseTimer(t)
            DestroyTimer(t)
        end
    end)

    ------------------

    local timerEnd = CreateTimer()
    local timerAlpha = CreateTimer()
    local alpha = 255
    TimerStart(timerEnd, duration, false, function()
        TimerStart(timerAlpha, 1/32, true, function()
            alpha = alpha - 2
            if alpha <= 0 then
                acidGlobal = false
                for ee = 1, #puddlesEffects do
                    BlzSetSpecialEffectAlpha(puddlesEffects[ee], 0)
                    DestroyEffect(puddlesEffects[ee])
                    puddlesEffects[ee] = nil
                    DestroyTimer(timerAlpha)
                end
                puddles = {}
                puddlesEffects = {}
            else
                for e = 1, #puddles do
                    BlzSetSpecialEffectAlpha(puddlesEffects[e], alpha)
                end
            end
            DestroyTimer(timerEnd)
        end)
    end)
end

function AcidBomb(startX, startY, endX, endY)
    if IsPointInCircle(endX, endY, CenterX, CenterY, Radius) then
        --SetUnitFacing(boss, angle*180 / math.pi)
        local maxZ = 820
        local startZ = 400
        local endZ = 220

        local points = ComputePath(startX, startY, startZ, endX, endY, endZ, maxZ, 30)
        local eff = AddSpecialEffect("Abilities\\Spells\\Other\\AcidBomb\\BottleMissile", startX, startY)
        --BlzSetSpecialEffectScale(eff, 1.5)
        local t = CreateTimer()
        local i = 1
        local sharp = #points

        TimerStart(t, 1/32, true, function()
            BlzSetSpecialEffectX(eff, points[i].x)
            BlzSetSpecialEffectY(eff, points[i].y)
            BlzSetSpecialEffectZ(eff, points[i].z)
            i = i + 1
            if i > sharp then
                PauseTimer(t)
                DestroyEffect(eff)

                local acid = AddSpecialEffect("models\\puddle2", points[i-2].x, points[i-2].y)
                BlzSetSpecialEffectYaw(acid, math.random() * 2 * math.pi)
                table.insert(puddles, {x = points[i-2].x, y = points[i-2].y})
                table.insert(puddlesEffects, acid)
                acidGlobal = true
                DestroyTimer(t)
            end
        end)
    end
end
function BeetleLaunch()
    local maxZ = 820
    local startZ = 400
    local endZ = 330
    local x, y = GetUnitPosition(slayer)
    local startX, startY = GetUnitPosition(boss)
    local eff = AddSpecialEffect("Units\\Undead\\ScarabLvl3\\ScarabLvl3", startX, startY)
    BlzPlaySpecialEffect(eff, ANIM_TYPE_WALK)
    BlzSetSpecialEffectScale(eff, 1.5)
    local angle = CalculateAngle(startX, startY, x, y)
    BlzSetSpecialEffectYaw(eff, angle)
    local points = ComputePath(startX, startY, startZ, x, y, endZ, maxZ, 30)

    local i = 1
    local sharp = #points
    local t = CreateTimer()

    TimerStart(t, 1/32, true, function()
        p = points[i]
        BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
        local xx, yy = GetUnitPosition(slayer)
        local angle = CalculateAngle(p.x, p.y, xx, yy)
        BlzSetSpecialEffectYaw(eff, angle)
        i = i + 1
        if i > sharp then
            PauseTimer(t)
            BeetleCharge(eff, p.x, p.y, p.z)
            DestroyTimer(t)
        end
    end)
end

function BeetleCharge(beetle, x, y, z)
    local ux, uy = GetUnitPosition(slayer)
    local endX, endY = FindIntersection(x, y, ux, uy)
    local points = GetPointsOnLine(x, y, endX, endY, 15)

    local markers = GetPointsOnLine(x, y, endX, endY, 120)
    local mrkrs = {}

    local angle = CalculateAngle(x, y, endX, endY)

    BlzSetSpecialEffectYaw(beetle, angle)

    for n = 1, #markers do
        local marker = AddSpecialEffect("models\\redtriangle3", markers[n].x, markers[n].y)
        BlzSetSpecialEffectYaw( marker, angle )
        table.insert(mrkrs, marker)
    end

    local i = 1
    local sharp = #points
    local counter = 1
    local index = 1
    local t = CreateTimer()
    TimerStart(t, 1/64, true, function()
        local p = points[i]
        BlzSetSpecialEffectPosition(beetle, p.x, p.y, z)
        if CheckBeetleDamage(p.x, p.y) then
            if not beetleAtached then
                BlzSetSpecialEffectPosition(beetle, 6000, 6000, 0)
                beetleAtached = true
                DestroyEffect(beetle)
                beetleAttach = AddSpecialEffectTarget("models\\beetle150", slayer, "chest")
                BeetlePeriodic()

                local frameTimer = CreateTimer()
                BlzDestroyFrame(beetleFrame)
                beetleFrame = BeetleFrame()
                local pos = 1.1
                BlzFrameSetVisible(beetleFrame, true)
                TimerStart(frameTimer, 1/32, true, function()
                    pos = pos - 0.02
                    BlzFrameSetAbsPoint(beetleFrame, FRAMEPOINT_CENTER, pos, 0.03)
                    if pos <= 0.87 then
                        DestroyTimer(frameTimer)
                    end
                end)

                for k = 1, #mrkrs do
                    DestroyEffect(mrkrs[k])
                end
                DestroyTimer(t)
            else
                for k = 1, #mrkrs do
                    DestroyEffect(mrkrs[k])
                end
                DestroyEffect(beetle)
                DestroyTimer(t)
            end
        end
        counter = counter + 1
        if math.fmod(counter, 8) == 0 then
            DestroyEffect(mrkrs[index])
            index = index + 1
        end
        i = i + 1
        if i > sharp then
            DestroyEffect(beetle)
            for k = 1, #mrkrs do
                DestroyEffect(mrkrs[k])
            end
            DestroyTimer(t)
        end


    end)
end

function BeetleFrame()
    local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
    BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 1.1, 0.03)
    BlzFrameSetSize(spriteframe, 0.001, 0.001)
    BlzFrameSetScale(spriteframe, 1)
    BlzFrameSetLevel(spriteframe, 3)
    BlzFrameSetModel(spriteframe, "sprites\\beetleSprite2", 1)
    BlzFrameSetSpriteAnimate(spriteframe, 2, 2)
    BlzFrameSetVisible(spriteframe, false)

    return spriteframe
end

function DestroyBeetleFrame()
    local frameTimer = CreateTimer()
    local pos = 0.87
    BlzFrameSetVisible(beetleFrame, true)
    TimerStart(frameTimer, 1/32, true, function()
        pos = pos + 0.02
        BlzFrameSetAbsPoint(beetleFrame, FRAMEPOINT_CENTER, pos, 0.03)
        if pos >= 1.1 then
            BlzDestroyFrame(beetleFrame)
            beetleFrame = nil
            DestroyTimer(frameTimer)
        end
    end)
    print("beetlframedestroy")
end



function Cage(radius, duration)
    local x, y = GetUnitPosition(slayer)
    local effects = {}
    hexPoints = GetHexagonPoints(x, y, radius, radius/2.5)
    local pointsChain = GetHexagonPoints(x, y, radius, 40)
    print(#hexPoints)
    local d = 1
    local sharp = #pointsChain
    local chainTimer = CreateTimer()
    PlayCage()
    TimerStart(chainTimer, 1/64, true, function()
        local p1 = pointsChain[d]
        local chain = AddSpecialEffect("models\\chainlink2", p1.x, p1.y )
        if d < #pointsChain then
            local angleChain = CalculateAngle(p1.x, p1.y, pointsChain[d+1].x, pointsChain[d+1].y)
            BlzSetSpecialEffectYaw(chain, angleChain)
            BlzSetSpecialEffectScale(chain, 1.15)
            table.insert(effects, chain)
        else
            local angleChain = CalculateAngle(p1.x, p1.y, pointsChain[1].x, pointsChain[1].y)
            BlzSetSpecialEffectYaw(chain, angleChain)
            BlzSetSpecialEffectScale(chain, 1.1)
            table.insert(effects, chain)
        end
        d = d + 1
        if d > sharp then
            for i = 1, #hexPoints do
                local p = hexPoints[i]
                local eff = AddSpecialEffect("models\\skeleton", p.x, p.y)
                local angle = CalculateAngle(p.x, p.y, x, y)
                BlzSetSpecialEffectYaw(eff, angle)
                table.insert(effects, eff)
            end
            CageOn = true
            ------------
            local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
            BlzFrameSetVisible(Mask, false)
            BlzFrameSetLevel(Mask,4)
            BlzFrameSetAbsPoint(Mask, FRAMEPOINT_CENTER, 0.8, 0.08)
            BlzFrameSetSize(Mask, 0.4, 0.23)
            BlzFrameSetTexture(Mask, "backdrops\\chain1", 0, true)
            BlzFrameSetAlpha(Mask, 255)

            local Mask1 = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
            BlzFrameSetVisible(Mask1, false)
            BlzFrameSetLevel(Mask1,4)
            BlzFrameSetAbsPoint(Mask1, FRAMEPOINT_CENTER, -0.05, 0.52)
            BlzFrameSetSize(Mask1, 0.4, 0.23)
            BlzFrameSetTexture(Mask1, "backdrops\\chain1", 0, true)
            BlzFrameSetAlpha(Mask1, 255)
            ------------

            local spriteframe = CageFrame()
            if IsPointInHexagon(GetUnitX(slayer), GetUnitY(slayer), hexPoints) then
                BlzFrameSetVisible(spriteframe, true)
                BlzFrameSetVisible(Mask1, true)
                BlzFrameSetVisible(Mask, true)
                SlayerInsideCage = true
                local frameTimer = CreateTimer()
                local pos = 1.1
                TimerStart(frameTimer, 1/32, true, function()
                    pos = pos - 0.02
                    BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, pos, -0.036)
                    if pos <= 0.82 then
                        DestroyTimer(frameTimer)
                    end
                end)
            end
            local cageTimer = CreateTimer()
            TimerStart(cageTimer, duration, false, function()
                for e = 1, #effects do
                    DestroyEffect(effects[e])
                end

                CageOn = false
                if SlayerInsideCage then
                    local frameTimer1 = CreateTimer()
                    local pos = 0.82
                    local alpha = 255
                    TimerStart(frameTimer1, 1/32, true, function()
                        pos = pos + 0.02
                        BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, pos, -0.036)

                        alpha = alpha - 17
                        BlzFrameSetAlpha(Mask1, alpha)
                        BlzFrameSetAlpha(Mask, alpha)
                        if pos >= 1.1 then
                            BlzDestroyFrame(spriteframe)
                            BlzDestroyFrame(Mask)
                            BlzDestroyFrame(Mask1)
                            DestroyTimer(frameTimer1)
                        end
                    end)
                end
                SlayerInsideCage = false
                hexPoints = {}
                DestroyTimer(cageTimer)
            end)
            DestroyTimer(chainTimer)
        end
    end)
end

function CageFrame()
    local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
    BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 1.1, -0.036)
    BlzFrameSetSize(spriteframe, 0.001, 0.001)
    BlzFrameSetScale(spriteframe, 1)
    BlzFrameSetLevel(spriteframe, 3)
    BlzFrameSetModel(spriteframe, "models\\skeletonsprite2", 1)
    BlzFrameSetSpriteAnimate(spriteframe, 2, 2)
    BlzFrameSetVisible(spriteframe, false)

    return spriteframe
end
function Bugs()
    local x1, y1 = GetRandomPointOnCircle(CenterX, CenterY, Radius)
    local x2, y2 = GetOppositePointOnCircle(CenterX, CenterY, x1, y1)

    local x3, y3, x4, y4 = GetPerpendicularDiameter(Radius, x1, y1, x2, y2)
    BugLine(x1, y1, x2, y2)
    BugLine(x3, y3, x4, y4)
end

function BugLine(x1, y1, x2, y2)
    local diameterPoints = GetPointsOnLine(x1, y1, x2, y2, 160)
    for n = #diameterPoints, 1, -1 do
        if IsPointInCircle(diameterPoints[n].x, diameterPoints[n].y, GetUnitX(boss), GetUnitY(boss), 20) then
            table.remove(diameterPoints, n)
            print("wrong bug")
        end
    end
    table.insert(diameterPoints, 1, {x = x1, y = y1})
    local angle = CalculateAngle(x1, y1, x2, y2)
    local effects = {}
    for a = 1, #diameterPoints do
        local eff = AddSpecialEffect("models\\bug", diameterPoints[a].x, diameterPoints[a].y)
        if a <= #diameterPoints/2 then
            BlzSetSpecialEffectYaw(eff, angle + math.pi/2)
        else
            BlzSetSpecialEffectYaw(eff, angle - math.pi/2)
        end
        local t = CreateTimer()
        TimerStart(t, 1, false, function()
            BlzPlaySpecialEffect(eff, ANIM_TYPE_WALK)
            DestroyTimer(t)
        end)
        table.insert(effects, eff)
    end

    local newAngle = 0
    local tim = CreateTimer()
    TimerStart(tim, 1/32, true, function()
        local points = RotateDiameter(diameterPoints, CenterX, CenterY, newAngle * math.pi/180)
        local yaw = CalculateAngle(points[1].x, points[1].y, points[#points].x, points[#points].y)
        for i = 1, #effects do
            local p = points[i]
            BlzSetSpecialEffectPosition(effects[i], p.x, p.y, 320)
            BlzSetSpecialEffectScale(effects[i], 2)
            if i <= #diameterPoints/2 then
                BlzSetSpecialEffectYaw(effects[i], yaw + math.pi/2)
            else
                BlzSetSpecialEffectYaw(effects[i], yaw -  math.pi/2)
            end

        end
        newAngle = newAngle + 1.5
        if newAngle > 360 then
            newAngle = 0
        end
    end)
end
function CorpseBombs()
    local x, y = GetUnitPosition(slayer)
    CorpseBomb(x, y)
    local t = CreateTimer()
    local i = 0
    TimerStart(t, 1.5, true, function()
        local x, y = GetUnitPosition(slayer)
        --local endP = RandomPointInCircle(x, y, 600)
        CorpseBomb(x, y)
        --CorpseBomb(endP[1], endP[2])
        i = i + 1
        if i> 5 then
            DestroyTimer(t)
        end
    end)

end

function CorpseBomb(targetX, targetY)
    local startX, startY = GetUnitPosition(boss)
    local endX, endY = GetRandomPointOnCircle(GetUnitX(slayer), GetUnitY(slayer), 600)
    local maxZ = 1200
    local startZ = 400
    local endZ = 353

    local points = ComputePathWithRotation(startX, startY, startZ, targetX, targetY, endZ, maxZ, 50)
    local t = CreateTimer()
    local i = 1
    local sharp = #points
    local eff = AddSpecialEffect("models\\MeatWagon", startX, startY)
    BlzSetSpecialEffectScale(eff, 0.75)
    local marker = AddSpecialEffect("models\\marker", targetX, targetY)
    BlzSetSpecialEffectScale(marker, 1.5)
    TimerStart(t, 1/32, true, function()
        local p = points[i]
        BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
        BlzSetSpecialEffectOrientation(eff, p.yaw, p.pitch, p.roll)

        i = i + 1
        if i > sharp then
            --BlzSetSpecialEffectOrientation(eff, 0, 0, 0)
            DestroyEffect(eff)
            local boom = AddSpecialEffect("Abilities\\Weapons\\FireBallMissile\\FireBallMissile", p.x, p.y)
            BlzSetSpecialEffectScale(boom, 2)
            DestroyEffect(boom)
            DestroyEffect(marker)
            BlzSetSpecialEffectRoll(eff, 0)
            BlzSetSpecialEffectPitch(eff, 0)
            CorpseFireworks(p.x, p.y, math.random(12, 24))
            CheckCorpseBombDamage(p.x, p.y)
            DestroyTimer(t)
        end
    end)
end

function CorpseFireworks(x, y, numb)
    for i = 1, numb do
        local eff = AddSpecialEffect("Abilities\\Weapons\\MeatwagonMissile\\MeatwagonMissile", x, y)
        local endP = RandomPointInCircle(x, y, 550)
        local marker = AddSpecialEffect("models\\marker", endP[1], endP[2])
        local maxZ = 820
        local startZ = 400
        local endZ = 320
        local points = ComputePath(x, y, startZ, endP[1], endP[2], endZ, maxZ, 20)

        local i = 1
        local sharp = #points
        local t = CreateTimer()
        TimerStart(t, 1/32, true, function()
            local p = points[i]
            BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
            i = i + 1
            if i > sharp then
                PauseTimer(t)
                DestroyEffect(eff)
                DestroyEffect(marker)
                CheckCorpseFireworksDamage(p.x, p.y)
                DestroyTimer(t)
            end
        end)
    end
end
function CreateBoss()
    boss = CreateUnit(Player(1), _('Uanb'), 0, 0, bj_UNIT_FACING)
    SetHeroLevel(boss, 10, false)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitInvulnerable(boss, true)
    print("works")
    Invulnerable()
end





function Invulnerable()
    SetUnitColor(boss, PLAYER_COLOR_RED)
end






function FireBall(startX, startY, endX, endY)
    --local angle = CalculateAngle(startX, endX, GetUnitX(slayer), GetUnitY(slayer))
    if IsPointInCircle(endX, endY, CenterX, CenterY, Radius) then
        --SetUnitFacing(boss, angle*180 / math.pi)
        SetUnitAnimationByIndex(boss, 7)
        local marker = AddSpecialEffect("models\\marker", endX, endY)
        BlzSetSpecialEffectScale(marker, 0.8)
        local maxZ = 820
        local startZ = 400
        local endZ = 220

        local points = ComputePath(startX, startY, startZ, endX, endY, endZ, maxZ, 30)
        local eff = AddSpecialEffect("Abilities\\Weapons\\FireBallMissile\\FireBallMissile", startX, startY)
        BlzSetSpecialEffectScale(eff, 1.5)
        local t = CreateTimer()
        local i = 1
        local sharp = #points

        TimerStart(t, 1/32, true, function()
            BlzSetSpecialEffectX(eff, points[i].x)
            BlzSetSpecialEffectY(eff, points[i].y)
            BlzSetSpecialEffectZ(eff, points[i].z)
            i = i + 1
            if i >= sharp then
                PauseTimer(t)
                CheckFireballDamage(points[i].x, points[i].y)
                DestroyEffect(marker)
                DestroyEffect(eff)
                DestroyTimer(t)
            end
        end)
    end
end

function FireBalls(time, bigCircleValue, littleCircleValue)
    --local time = 0.15
    --local bigCircleValue = 10
    --local littleCircleValue = 20


    local startX, startY = GetUnitPosition(boss)
    local endX, endY = GetUnitPosition(slayer)

    local targets = {}
    table.insert(targets, {endX, endY})

    for i = 1, littleCircleValue do
        table.insert(targets, RandomPointInCircle(endX, endY, 600))
    end
    for ii = 1, bigCircleValue do
        table.insert(targets, RandomPointInCircle(CenterX, CenterY, Radius))
    end
    local t = CreateTimer()
    local a = 1
    TimerStart(t, time, true, function()
        FireBall(startX, startY, targets[a][1], targets[a][2])
        a=a+1
        if a > #targets then
            PauseTimer(t)
            DestroyTimer(t)
        end
    end)
end
function ThrowStone()
    local bx, by = GetUnitPosition(boss)
    local sx, sy = RandomPointInCircleXY(GetUnitX(slayer), GetUnitY(slayer), 400)
    local targetX, targetY = FindIntersection(bx, by, sx, sy)
    local points = GetPointsOnLineWithRotation(bx, by, targetX, targetY, 50)
    local eff = AddSpecialEffect("models\\Rock3", bx, by)
    BlzSetSpecialEffectScale(eff, 0.75)
    BlzSetSpecialEffectZ(eff, 350)


    local t = CreateTimer()
    local i = 1
    local sharp = #points
    TimerStart(t, 1/32, true, function()
        local pt = points[i]
        BlzSetSpecialEffectPosition(eff, pt.x,pt.y, 350)
        if CheckStoneDamage(pt.x, pt.y) then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSound()
            DestroyTimer(t)
        end
        --BlzSetSpecialEffectYaw(eff, pt.yaw)
        --BlzSetSpecialEffectPitch(eff, pt.pitch)
        --BlzSetSpecialEffectRoll(ff, pt.roll)
        BlzSetSpecialEffectOrientation(eff, pt.yaw, pt.pitch, pt.roll)
        i = i + 1
        if i > sharp then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSoundMain(pt.x, pt.y)
            DestroyTimer(t)
        end
    end)
end

function ThrowStones(duration)
    local points = RotatePoints(GetUnitX(boss), GetUnitY(boss), 200, 5)
    local t = {}
    for i = 1, 4 do
        local eff = AddSpecialEffect("models\\Rock3", points[i][1][1], points[i][1][2])
        BlzSetSpecialEffectScale(eff, 0.75)
        BlzSetSpecialEffectYaw(eff, math.random(1, 3))
        BlzSetSpecialEffectZ(eff, 350)
        table.insert(t, eff)
    end
    local rotateTimer = CreateTimer()
    local cd = CreateTimer()
    local waitDuration = CreateTimer()


    local n = 1
    local sharp = #points[1]
    TimerStart(rotateTimer, 1/32, true, function()
        for a = 1, 4 do
            BlzSetSpecialEffectPosition(t[a], points[a][n][1], points[a][n][2], 350)
        end
        if n == sharp then
            n = 2
        else
            n=n+1
        end
    end)
    TimerStart(cd, 0.5, true, function()
        ThrowStone()
    end)
    TimerStart(waitDuration, duration, false, function()
        PauseTimer(cd)
        DestroyTimer(cd)
        PauseTimer(rotateTimer)
        DestroyTimer(rotateTimer)
        for m = 1, #t do
            DestroyEffect(t[m])
        end
        DestroyTimer(waitDuration)
    end)
end
function TripleImpale(d)
    print("triple impale")

    local targetX, targetY = GetUnitPosition(slayer)
    local target1 = {targetX, targetY}

    local casterX, casterY = GetUnitPosition(boss)
    local casterX, casterY = GetPointOnLine(casterX, casterY, targetX, targetY, 80)


    local angle, distance = CalculateAngleAndDistance(casterX, casterY, targetX, targetY)
    SetUnitFacing(boss, angle*180 / math.pi)
    SetUnitAnimationByIndex(boss, 7)

    local leftAngle = angle + math.rad(d)
    local rightAngle = angle - math.rad(d)

    local target1X = casterX + distance * math.cos(leftAngle)
    local target1Y = casterY + distance * math.sin(leftAngle)
    local target2 = {target1X, target1Y}

    local target2X = casterX + distance * math.cos(rightAngle)
    local target2Y = casterY + distance * math.sin(rightAngle)
    local target3 = {target2X, target2Y}

    local targets = {target1, target2, target3}
    local angles = {angle, leftAngle, rightAngle}
    local points = {}
    local endpoints = {}

    for i = 1, #impaleCasters do
        local endpointX, endpointY = FindIntersection(casterX, casterY, targets[i][1], targets[i][2])
        table.insert(endpoints, i, {endpointX, endpointY})
        local trueDistance = CalculateDistance(casterX, casterY, endpointX, endpointY)
        local impspll = BlzGetUnitAbility(impaleCasters[i], _('AUim'))
        BlzSetAbilityRealLevelField(impspll, ABILITY_RLF_WAVE_DISTANCE, 0, trueDistance)
        SetUnitPositionWithFacing(impaleCasters[i], casterX, casterY, angles[i])
        local linePoints = GetPointsOnLine(casterX, casterY, endpointX, endpointY, 100)
        table.insert(points, i, linePoints)


    end
    print(GetUnitPosition(impaleCasters[1]))

    local effects = {}
    local iTable = {1, 1, 1}
    for l = 1, 3 do
        TimerStart( CreateTimer(), 1/#points[l], true, function()
            eff = AddSpecialEffect("models\\redtriangle3", points[l][iTable[l]].x, points[l][iTable[l]].y)
            BlzSetSpecialEffectYaw( eff, angles[l] )
            PlayImpaleMarkerSound(points[l][iTable[l]].x, points[l][iTable[l]].y)
            table.insert(effects, eff)
            iTable[l] = iTable[l] + 1
            if iTable[l] == #points[l] then
                PauseTimer(GetExpiredTimer())
                DestroyTimer(GetExpiredTimer())
            end
        end)
    end

    local castDelay = CreateTimer()
    TimerStart(castDelay, 0.75, false, function()


        IssuePointOrder(dummy1, "impale", endpoints[1][1], endpoints[1][2])

        IssuePointOrder(dummy2, "impale", endpoints[2][1], endpoints[2][2])

        IssuePointOrder(dummy3, "impale", endpoints[3][1], endpoints[3][2])


        local t1 = CreateTimer()
        TimerStart(t1, 0.4, false, function()
            CameraSetEQNoiseForPlayer( Player(0), 30.00 )
            PlayImpaleSound()
            DestroyTimer(t1)
        end)

        local t2 = CreateTimer()
        TimerStart(t2, 0.65, false, function()
            CameraClearNoiseForPlayer( Player(0) )
            print(#effects)
            for e = 1, #effects do
                DestroyEffect(effects[e])
            end
            DestroyTimer(t2)
        end)

        local t = CreateTimer()
        TimerStart(t, 0.75, false, function()
            for i = 1, 3 do
                SetUnitPosition(impaleCasters[i], -1500, -1500)
            end
            DestroyTimer(t)
        end)
        DestroyTimer(castDelay)
    end)
end
function ChainHook()
    if chainMarker and not Chaining and not chaincooldown then
        chainMarker = false
        local function MoveToTheTarget(points, effects, sharp)
            local i = 1
            local t2 = CreateTimer()
            TimerStart( t2, 1/64, true, function()
                p = points[i]
                DestroyEffect(effects[i])
                if IsPointInCircle(p.x, p.y, CenterX, CenterY, Radius) then
                    if not CageOn then --блок для проверки на границы костяной тюрьмы, нужно вынести в отдельную функцию
                        SetUnitPosition(slayer, p.x, p.y)
                        FixCursor(p.x, p.y)
                    elseif SlayerInsideCage then
                        local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                        if not IsPointInHexagon(xx, yy, hexPoints) then
                            for e = 1, #effects do
                                DestroyEffect(effects[e])
                            end
                            IssueImmediateOrder(slayer, "stop")
                            EnableTrigger(ClickTrigger)
                            SetUnitInvulnerable(slayer, false)
                            InitWalkTimer()
                            --PauseUnit(slayer, false)
                            SetUnitMoveSpeed(slayer, 522)
                            Chaining = false
                            DestroyTimer(t2)
                        else
                            SetUnitPosition(slayer, p.x, p.y)
                            FixCursor(p.x, p.y)
                        end
                    else
                        local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 80)
                        if IsPointInHexagon(xx, yy, hexPoints) then
                            for e = 1, #effects do
                                DestroyEffect(effects[e])
                            end
                            IssueImmediateOrder(slayer, "stop")
                            EnableTrigger(ClickTrigger)
                            SetUnitInvulnerable(slayer, false)
                            InitWalkTimer()
                            --PauseUnit(slayer, false)
                            SetUnitMoveSpeed(slayer, 522)
                            Chaining = false
                            DestroyTimer(t2)
                        else
                            SetUnitPosition(slayer, p.x, p.y)
                            FixCursor(p.x, p.y)
                        end
                    end
                end
                i = i + 1
                if i > sharp - 8 then
                    Chaining = false
                end
                if i > sharp then
                    PauseTimer(t2)
                    EnableTrigger(ClickTrigger)
                    SetUnitInvulnerable(slayer, false)
                    InitWalkTimer()
                    --PauseUnit(slayer, false)
                    SetUnitMoveSpeed(slayer, 522)
                    Chaining = false
                    DestroyTimer(t2)
                end
            end)
        end

        local targets = {}
        local cursorX = BlzGetTriggerPlayerMouseX()
        local cursorY = BlzGetTriggerPlayerMouseY()
        if IsPointInCircle(cursorX, cursorY, CenterX, CenterY, Radius) then
            local x, y = GetUnitPosition(slayer)


            local target = FindClosestUnit(creeps, cursorX, cursorY)
            local tX, tY = GetUnitPosition(target)

            if IsPointInCircle(x, y, CenterX, CenterY, Radius) and IsPointInCircle(tX, tY, x, y, 870) and IsPointInCircle(tX, tY, cursorX, cursorY, 150) then
                Chaining = true
                chaincooldown = true
                local cdtimer = CreateTimer()
                TimerStart(cdtimer, 2, false, function()
                    chaincooldown = false
                    DestroyTimer(cdtimer)
                end)
                DisableTrigger(ClickTrigger)
                DestroyTimer(walkTimer)
                SetUnitInvulnerable(slayer, true)
                PlayChain()
                --PauseUnit(slayer, true)
                SetUnitMoveSpeed(slayer, 0)
                IssueImmediateOrder(slayer, "stop")
                local x1, y1 = GetPointOnLine(tX, tY, x, y, 36)
                local points = GetPointsOnLine(x, y, x1, y1, 34)
                table.remove(points, #points)
                local i = 1
                local sharp = #points
                local angle = CalculateAngle(x, y, x1, y1)
                local t = CreateTimer()
                local effects = {}

                TimerStart( t, 1/64, true, function()
                    p = points[i]
                    eff = AddSpecialEffect("models\\chainlink1", p.x, p.y)
                    BlzSetSpecialEffectYaw( eff, angle )
                    table.insert(effects, eff)
                    i = i + 1
                    if i > sharp then
                        PauseTimer(t)
                        MoveToTheTarget(points, effects, sharp)
                        DestroyTimer(t)
                    end
                end)
            else
                PlayBrokenChain()
            end
        end
    end
end

--globalMarkerDistance = 0
function FindChainTarget()
    ------fix double circle
    if (not chainMarker) or (not rmbpressed) then
        for b = 1, #slayerEffects do
            DestroyEffect(slayerEffects[b])
        end
        for b = 1, #slayerEffectsRed do
            DestroyEffect(slayerEffectsRed[b])
        end
        for b = 1, #targetEffects do
            DestroyEffect(targetEffects[b])
        end
        slayerEffects = {}
        slayerEffectsRed = {}
        targetEffects = {}
    end
    --------
    if chainMarker == false then
        for i = 1, 32 do --создали пул эффектов вне зоны видимости
            local eff = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
            BlzSetSpecialEffectScale(eff, 0.5)
            BlzSetSpecialEffectColor(eff, 0, 255, 0)
            table.insert(slayerEffects, eff)
            local effr = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
            BlzSetSpecialEffectScale(effr, 0.5)
            BlzSetSpecialEffectColor(effr, 255, 0, 0)
            table.insert(slayerEffectsRed, effr)
        end

        local effT = AddSpecialEffect("models\\aoe_indicator", -6000, -6000) --models\\greencircle
        BlzSetSpecialEffectColor(effT, 0, 255, 0)
        BlzSetSpecialEffectScale(effT, 2)
        table.insert(targetEffects, effT)
        local effTr = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
        BlzSetSpecialEffectColor(effTr, 255, 0, 0)
        BlzSetSpecialEffectScale(effTr, 2)
        table.insert(targetEffects, 2, effTr)
        local effST = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
        BlzSetSpecialEffectScale(effST, 11)
        BlzSetSpecialEffectColor(effST, 0, 255, 0)
        table.insert(targetEffects, 3, effST)

        chainMarker = true
        local t = CreateTimer()
        TimerStart(t, 1/32, true, function()
            local ux, uy = GetUnitPosition(slayer)
            local target = FindClosestUnit(creeps, globalCursorX, globalCursorY)

            local tX, tY = GetUnitPosition(target)

            BlzSetSpecialEffectPosition(targetEffects[3], ux, uy, 320)


            local mx = BlzGetTriggerPlayerMouseX()
            --print(globalCursorX)
            local points = GetPointsOnLine(ux, uy, tX, tY, 60)
            local thetable = {}
            if IsPointInCircle(tX, tY, globalCursorX, globalCursorY, 150) then
                BlzSetSpecialEffectPosition(targetEffects[2], -6000, -6000, 320)
                BlzSetSpecialEffectPosition(targetEffects[1], tX, tY, 320)
            else
                BlzSetSpecialEffectPosition(targetEffects[1], -6000, -6000, 320)
                BlzSetSpecialEffectPosition(targetEffects[2], tX, tY, 320)
            end
            if IsPointInCircle(ux, uy, CenterX, CenterY, Radius) and IsPointInCircle(tX, tY, ux, uy, 870) then

                for a = 1, #slayerEffectsRed do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], -6000, -6000, 370)
                end

                for a = 1, #points do
                    BlzSetSpecialEffectPosition(slayerEffects[a], points[a].x, points[a].y, 370)
                end

                for a = #points + 1, #slayerEffects do
                    BlzSetSpecialEffectPosition(slayerEffects[a], -6000, -6000, 370)
                end
            else
                if not IsPointInCircle(ux, uy, CenterX, CenterY, Radius) then
                    chainMarker = false
                    for b = 1, #slayerEffects do
                        DestroyEffect(slayerEffects[b])
                    end
                    for b = 1, #slayerEffectsRed do
                        DestroyEffect(slayerEffectsRed[b])
                    end
                    DestroyTimer(t)
                end

                for a = 1, #slayerEffects do
                    BlzSetSpecialEffectPosition(slayerEffects[a], -6000, -6000, 370)
                end

                for a = 1, #points do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], points[a].x, points[a].y, 370)
                end

                for a = #points + 1, #slayerEffectsRed do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], -6000, -6000, 370)
                end
            end

            if (not chainMarker) or (not rmbpressed) then
                for b = 1, #slayerEffects do
                    DestroyEffect(slayerEffects[b])
                end
                for b = 1, #slayerEffectsRed do
                    DestroyEffect(slayerEffectsRed[b])
                end
                for b = 1, #targetEffects do
                    DestroyEffect(targetEffects[b])
                end
                slayerEffects = {}
                slayerEffectsRed = {}
                targetEffects = {}
                DestroyTimer(t)
            end
        end)
    end
end
function Dash()
    local distance = 400

    local mouseX, mouseY = GetUnitPosition(posdummy)

    local slayerX, slayerY = GetUnitPosition(slayer)

    local x, y = GetPointOnLine(slayerX, slayerY, mouseX, mouseY, distance)

    local points = GetPointsOnLine(slayerX, slayerY, x, y, 40)
    local i = 1
    local sharp = #points
    PlayDashSound()
    local t = CreateTimer()
    TimerStart(t, 1/64, true, function()
        if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) then
            local p = points[i]
            if not CageOn then
                local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                DestroyEffect(eff)
                SetUnitPosition(slayer, p.x, p.y)
                SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                FixCursor(p.x, p.y)
                i = i + 1
                if i > sharp then
                    DestroyTimer(t)
                end
            elseif SlayerInsideCage then
                local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                if not IsPointInHexagon(xx, yy, hexPoints) then
                    IssueImmediateOrder(slayer, "stop")
                    DestroyTimer(t)
                else
                    local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                    DestroyEffect(eff)
                    SetUnitPosition(slayer, p.x, p.y)
                    SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                    FixCursor(p.x, p.y)
                    i = i + 1
                    if i > sharp then
                        DestroyTimer(t)
                    end
                end
            else
                local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                if IsPointInHexagon(xx, yy, hexPoints) then
                    IssueImmediateOrder(slayer, "stop")
                    DestroyTimer(t)
                else
                    local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                    DestroyEffect(eff)
                    SetUnitPosition(slayer, p.x, p.y)
                    SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                    FixCursor(p.x, p.y)
                    i = i + 1
                    if i > sharp then
                        DestroyTimer(t)
                    end
                end
            end
        else
            DestroyTimer(t)
        end
    end)
end

function MakeShot(x, y)
    local startx, starty = GetUnitPosition(slayer)
    if IsPointInCircle(startx, starty, CenterX, CenterY, Radius - 20) then
        if not cooldown then
            if not beetleAtached then
                --cooldown = true
                --local cooldownTimer = CreateTimer()
                --TimerStart(cooldownTimer, 0.2, false, function()
                --cooldown = false
                --end)
                local projectile = AddSpecialEffect("Abilities\\Weapons\\GyroCopter\\GyroCopterMissile", startx, starty)


                local targetx = BlzGetTriggerPlayerMouseX()
                local targety = BlzGetTriggerPlayerMouseY()

                local angle, distance = CalculateAngle(startx, starty, targetx, targety)
                BlzSetSpecialEffectYaw( projectile, angle )
                BlzSetSpecialEffectZ(projectile, 350)
                local endpointX, endpointY = FindIntersection(startx, starty, targetx, targety)
                local hitplaceX, hitplaceY = RayCircleIntersection(startx, starty, endpointX, endpointY, GetUnitX(boss), GetUnitY(boss), 120)

                local movePoints = GetPointsOnLine(startx, starty, endpointX, endpointY, 20)
                local sharp = #movePoints
                local i = 1
                local t = CreateTimer()
                if hitplaceX == nill then
                    TimerStart(t, 1/64, true, function()
                        BlzSetSpecialEffectX(projectile, movePoints[i].x)
                        BlzSetSpecialEffectY(projectile, movePoints[i].y)
                        BlzSetSpecialEffectZ(projectile, 350)

                        for a = 1, #creeps do
                            local testX, testY = GetUnitPosition(creeps[a])
                            if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                                PauseTimer(t)
                                DestroyEffect(projectile)
                                ControlDmg(creeps[a])
                                DestroyTimer(t)
                            end
                        end
                        i = i+1
                        if i > sharp then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            DestroyTimer(t)
                        end
                    end)
                else
                    TimerStart(t, 1/64, true, function()
                        BlzSetSpecialEffectX(projectile, movePoints[i].x)
                        BlzSetSpecialEffectY(projectile, movePoints[i].y)
                        BlzSetSpecialEffectZ(projectile, 350)
                        local d = CalculateDistance(movePoints[i].x, movePoints[i].y, hitplaceX, hitplaceY)
                        local testX, testY = GetUnitPosition(testUnit)
                        for a = 1, #creeps do
                            local testX, testY = GetUnitPosition(creeps[a])
                            if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                                PauseTimer(t)
                                DestroyEffect(projectile)
                                ControlDmg(creeps[a])
                                DestroyTimer(t)
                            end
                        end
                        if d <= 10 then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            DestroyTimer(t)
                        end
                        i = i+1
                        if i > sharp then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            DestroyTimer(t)
                        end
                    end)
                end
            else
                local projectile = AddSpecialEffect("Abilities\\Weapons\\GyroCopter\\GyroCopterMissile", startx, starty)
                DestroyEffect(projectile)
                beetleHP = beetleHP - 1
                print(beetleHP)
                if beetleHP <= 0 then
                    DestroyEffect(beetleAttach)
                    DestroyBeetleFrame()
                    --beetleAttach = nil
                    beetleAtached = false
                    beetleHP = 3
                end
            end
        end
    end
end

function Sawing()
    local targets = {}
    local x, y = GetUnitPosition(slayer)


    local target = FindClosestUnit(creeps, x, y)
    local tX, tY = GetUnitPosition(target)
    if IsPointInCircle(tX, tY, x, y, 350) and not Chaining and not dashing then
        sawing = true
        SetUnitPosition(slayer, tX, tY)
        SetUnitInvulnerable(slayer, true)
        CameraSetFocalDistance(50)
        local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)

        PlaySawFleshSound()
        PlayScream()
        BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 0.4, 0.3)
        BlzFrameSetLevel(spriteframe, 3)
        BlzFrameSetModel(spriteframe, "acowtf3", 0)
        BlzFrameSetSpriteAnimate(spriteframe, 0, 0)
        -- birth = 0
        -- death = 1
        -- stand = 2
        -- morph = 3
        -- alternate = 4
        CinematicFilterGenericBJ( 0.00, BLEND_MODE_BLEND, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 100, 100, 100, 25.00, 100.00, 100.00, 100.00, 25.00 )
        BlzFrameSetVisible(spriteframe, true)
        local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
        BlzFrameSetLevel(Mask,4)
        BlzFrameSetAbsPoint(Mask, FRAMEPOINT_TOPLEFT, -0.14, 0.6)
        BlzFrameSetAbsPoint(Mask, FRAMEPOINT_BOTTOMRIGHT, 0.95, 0.0)
        BlzFrameSetTexture(Mask, "backdrops\\blood2", 0, true)
        BlzFrameSetAlpha(Mask, 0)
        local alpha = 0
        TimerStart(CreateTimer(), 1/32, true, function()
            alpha = alpha + 4
            if alpha >=255 then
                BlzFrameSetAlpha(Mask, 255)
                DestroyTimer(GetExpiredTimer())
            else
                BlzFrameSetAlpha(Mask, alpha)
            end
        end)

        local focal = 50

        TimerStart(CreateTimer(), 3, false, function()
            BlzDestroyFrame(spriteframe)
            DisplayCineFilterBJ( false )
            TimerStart(CreateTimer(), 1/32, true, function()
                focal = focal + 10
                if focal >=500 then
                    CameraSetFocalDistance(0)
                    DestroyTimer(GetExpiredTimer())
                else
                    CameraSetFocalDistance(focal)
                end
            end)
            TimerStart(CreateTimer(), 1/32, true, function()
                alpha = alpha - 4
                if alpha <=0 then
                    BlzFrameSetAlpha(Mask, 0)
                    BlzDestroyFrame(Mask)
                    DestroyTimer(GetExpiredTimer())
                else
                    BlzFrameSetAlpha(Mask, alpha)
                end
            end)
            SetUnitInvulnerable(slayer, false)
            sawing = false
            DestroyTimer(GetExpiredTimer())
        end)
    end
end
function CreateSlayer()
    slayer = CreateUnit(Player(1), _('hrif'), 600, 200, bj_UNIT_FACING)
    SetUnitPathing(slayer, true)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitMoveSpeed(slayer, 522)



end






--CUSTOM_CODE
function InitCustomPlayerSlots()
SetPlayerStartLocation(Player(0), 0)
SetPlayerColor(Player(0), ConvertPlayerColor(0))
SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
SetPlayerRaceSelectable(Player(0), true)
SetPlayerController(Player(0), MAP_CONTROL_USER)
end

function InitCustomTeams()
SetPlayerTeam(Player(0), 0)
end

function main()
SetCameraBounds(-5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
NewSoundEnvironment("Default")
SetAmbientDaySound("NorthrendDay")
SetAmbientNightSound("NorthrendNight")
SetMapMusic("Music", true, 0)
InitBlizzard()
InitGlobals()
end

function config()
SetMapName("TRIGSTR_001")
SetMapDescription("TRIGSTR_003")
SetPlayers(1)
SetTeams(1)
SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
DefineStartLocation(0, 0.0, 0.0)
InitCustomPlayerSlots()
SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
InitGenericPlayerSlots()
end

