function InitGlobals()
end

--CUSTOM_CODE
do
    local real = MarkGameStarted
    function MarkGameStarted()
        FogMaskEnableOff()
        FogEnableOff()
        GetUnitX = GetUnitRealX
        GetUnitY = GetUnitRealY
        CreateBoss()
        CreateTestUnit()
        InitControlKeys()
        dummy1 = CreateDummy()
        dummy2 = CreateDummy()
        dummy3 = CreateDummy()
        posdummy = CreateDummy()
        impaleCasters = {dummy1, dummy2, dummy3}
        --BlzHideOriginFrames(true)
        CreateSlayer()
        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        globalX, globalY = GetUnitPosition(slayer)
        InitControlMouse()
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)


        --------------------
        CenterX = 1
        CenterY = 1
        Radius = 1400

        ClickBlocker = BlzCreateFrameByType("TEXT", "name", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
         CreateTextFrame(ClickBlocker, -0.1338, 0.6, 0.936020, 0, 1, "", 1)
            BlzFrameSetEnable(ClickBlocker, true)


        InitCameraScrollBar()
        InitDamageTrigger()

    end
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 14.05.2023 20:47
---
function SetGameCamera(preset)
    if preset == 40 then
        ResetToGameCamera( 1 )
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 60 then
        local t = {1480, 4800, 16, 310, 62, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 80 then
        local t = {800, 4000, 16, 338.045, 30.0027917027, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 0 then
        local t = {3000, 5400, 16, 304, 90, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 20 then
        local t = {2400, 5400, 16, 304, 80, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
end

function SetCameraFields(t, d)
    SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, t[1], d)
    SetCameraField(CAMERA_FIELD_FARZ, t[2], d)
    SetCameraField(CAMERA_FIELD_NEARZ, t[3], d)
    SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, t[4], d)
    SetCameraField(CAMERA_FIELD_FIELD_OF_VIEW, t[5], d)
    SetCameraField(CAMERA_FIELD_ROTATION, t[6])
    SetCameraField(CAMERA_FIELD_ZOFFSET, t[7])
    --------------------
    SetCameraField(CAMERA_FIELD_ROLL, 0.0)
    SetCameraField(CAMERA_FIELD_LOCAL_PITCH, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_YAW, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_ROLL, 0)
end

function InitControlKeys()

    KeyTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_Q, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_V, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_E, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_SPACE, 0, true)
    TriggerAddCondition(KeyTrigger, Condition(ControlKeys))

    ------MOVING SYSTEM------
    orders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица текущих направлений
    futureOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица будущих направлений, нужно хранить, чтобы можно было быстро перемещаться в противоположную сторону
    additionalOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --нужна для хранения направлений, заданных кратковременными нажатиями, и не попавших в основные из-за тика таймера

    Apressed = false
    Wpressed = false
    Spressed = false
    Dpressed = false

    ButtonPressedTrigger = CreateTrigger()
    ButtonReleasedTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_A, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_A, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_W, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_W, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_S, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_S, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_D, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_D, 0, false)

    TriggerAddCondition(ButtonPressedTrigger, Condition(ButtonPressed))
    TriggerAddCondition(ButtonReleasedTrigger, Condition(ButtonReleased))

    local t = CreateTimer()
    TimerStart(t, 1/16, true, function()
        if (Apressed or Wpressed or Dpressed or Spressed) and not Chaining then --and not (Apressed and Dpressed) and not (Wpressed and Spressed))
            --local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            --local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            if orders.Xm == 300 and orders.Xp == 300 then
                if not Apressed then
                    orders.Xm = 0
                end
                if not Dpressed then
                    orders.Xp = 0
                end
            end
            if orders.Ym == 300 and orders.Yp == 300 then
                if not Spressed then
                    orders.Ym = 0
                end
                if not Wpressed then
                    orders.Yp = 0
                end
            end

            local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            IssuePointOrder(slayer, "move", x, y)
            FixPosition()
            --print(orders.Xm.." "..orders.Xp.." "..orders.Ym.." "..orders.Yp.." "..x.." "..y.." "..ux.." "..uy)
        elseif --(not Apressed and not Wpressed and not Dpressed and not Spressed) and
            (additionalOrders.Xm ~= 0 or additionalOrders.Xp ~= 0 or additionalOrders.Ym ~= 0 or additionalOrders.Yp ~= 0) and not Chaining then
            --print("additional condition")
            for k, v in pairs(additionalOrders) do
                if v ~= 0 then
                    orders[k] = v
                    additionalOrders[k] = 0
                end
            end
            local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            IssuePointOrder(slayer, "move", x, y)
            FixPosition()
        else
            orders.Xm = 0
            orders.Yp = 0
            orders.Xp = 0
            orders.Ym = 0
            IssueImmediateOrder(slayer, "stop")
        end
    end)
end

function ButtonPressed()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = true
        if Dpressed == false then
            orders.Xm = 300
            additionalOrders.Xm = 300
        else
            futureOrders.Xm = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = true
        if Spressed == false then
            orders.Yp = 300
            additionalOrders.Yp = 300
        else
            futureOrders.Yp = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = true
        if Wpressed == false then
            orders.Ym = 300
            additionalOrders.Ym = 300
        else
            futureOrders.Ym = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = true
        if Apressed == false then
            orders.Xp = 300
            additionalOrders.Xp = 300
        else
            futureOrders.Xp = 300
        end
    end
    --local ux, uy = GetUnitPosition(slayer)
    --local x = ux - orders.Xm + orders.Xp
    --local y = uy - orders.Ym + orders.Yp
    --local angle = CalculateAngle(ux, uy, x, y)
    --BlzSetUnitFacingEx(slayer, angle)
    --IssuePointOrder(slayer, "move", x, y)

end

function ButtonReleased()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = false
        orders.Xm = 0
        if futureOrders.Xp ~= 0 then
            orders.Xp = futureOrders.Xp
            futureOrders.Xp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = false
        orders.Yp = 0
        if futureOrders.Ym ~= 0 then
            orders.Ym = futureOrders.Ym
            futureOrders.Ym = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = false
        orders.Ym = 0
        if futureOrders.Yp ~= 0 then
            orders.Yp = futureOrders.Yp
            futureOrders.Yp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = false
        orders.Xp = 0
        if futureOrders.Xm ~= 0 then
            orders.Xm = futureOrders.Xm
            futureOrders.Xm = 0
        end
    end
   -- local x = GetUnitX(slayer) + orders.Xm + orders.Xp
   -- local y = GetUnitY(slayer) + orders.Ym + orders.Yp
  --  local ux, uy = GetUnitPosition(slayer)
 --   local x = ux - orders.Xm + orders.Xp
 --   local y = uy - orders.Ym + orders.Yp
 --   IssuePointOrder(slayer, "move", x, y)
end


function ControlKeys()
    if BlzGetTriggerPlayerKey() == OSKEY_Q then
        print("Q")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        TimerStart(CreateTimer(), 2, true, function()
            FireBalls()
        end)
    end
    if BlzGetTriggerPlayerKey() == OSKEY_E then
        print("E")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        Sawing()
    end
    if BlzGetTriggerPlayerKey() == OSKEY_V then
        CameraSetFocalDistance(0)
        print("V")

        --print(GetCameraField(CAMERA_FIELD_TARGET_DISTANCE))
        --print(GetCameraField(CAMERA_FIELD_FARZ))
        --print(GetCameraField(CAMERA_FIELD_NEARZ))
        --print(GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK))
        --print(GetCameraField(CAMERA_FIELD_FIELD_OF_VIEW))
        --print(GetCameraField(CAMERA_FIELD_ROLL))
        --print(GetCameraField(CAMERA_FIELD_ROTATION))
        --print(GetCameraField(CAMERA_FIELD_ZOFFSET))
        --print(GetCameraField(CAMERA_FIELD_LOCAL_PITCH))
        --print(GetCameraField(CAMERA_FIELD_LOCAL_YAW))
        --print(GetCameraField(CAMERA_FIELD_LOCAL_ROLL))
        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        --spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0), "", 0)

                --BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 0.4, 0.3)
                --BlzFrameSetLevel(spriteframe, 3)
               -- BlzFrameSetSize(spriteframe, 0.01, 0.01)
               -- BlzFrameSetModel(spriteframe, "aco", 0)
                --BlzFrameSetScale(spriteframe, 0.00058)
              --  BlzFrameSetSpriteAnimate(spriteframe, 5, 2)
                -- birth = 0
                -- death = 1
                -- stand = 2
                -- morph = 3
                -- alternate = 4
               -- BlzFrameSetVisible(spriteframe, true)
        --SelectUnit(boss, true)
        --local t = RandomPointInCircle(CenterX, CenterY, Radius)
        --local eff = AddSpecialEffect("models\\Rock3", t[1], t[2])
       -- BlzSetSpecialEffectScale(eff, 0.75)
        --BlzSetSpecialEffectYaw(eff, math.random(1, 3))
       -- BlzSetSpecialEffectZ(eff, 350)
       -- TimerStart(CreateTimer(), 1, false, function()
      --      DestroyEffect(eff)
      --      local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac",false, true, false, 10, 10, "DefaultEAXON")
      --      SetSoundChannel( snd, 0)
        --    SetSoundDistances( snd, 600.00, 3200 )
            --SetSoundDistanceCutoff( snd, 3000.00)
     --       SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
     --       SetSoundVolume( snd, 80)
            --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
            --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
            --SetSoundPitch( snd, 1.0 )
      --      SetSoundPosition(snd, t[1], t[2],100)
       --     StartSound(snd)
      --      KillSoundWhenDone(snd)
        --    DestroyTimer(GetExpiredTimer())
       -- end)
        --ThrowStones(10)
        TripleImpale(35)
        CreateTestUnit()
    end

    if BlzGetTriggerPlayerKey() == OSKEY_SPACE then
        print("SPACE")
        Dash()
    end
end


function InitControlMouse()
    MouseTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(MouseTrigger, Player(0), EVENT_PLAYER_MOUSE_MOVE)
    TriggerAddCondition(MouseTrigger, Condition(ControlMouse))

  ClickTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(ClickTrigger, Player(0), EVENT_PLAYER_MOUSE_DOWN)
    TriggerAddCondition(ClickTrigger, Condition(Clicker))

WheelTrigger = CreateTrigger()
    BlzTriggerRegisterFrameEvent(WheelTrigger, InfoBackground, FRAMEEVENT_MOUSE_WHEEL)
    TriggerAddAction(trigger, function()
        print("wheel")
    end)
  -- ClickReleaseTrigger = CreateTrigger()
 --  TriggerRegisterPlayerEvent(ClickReleaseTrigger, Player(0), EVENT_PLAYER_MOUSE_UP)
   -- TriggerAddCondition(ClickReleaseTrigger, Condition(Releaser))


end

function ControlMouse()
    SetUnitFaceToCursor()
end

function CancelClick()
    print("world click")
    ForceUICancelBJ(Player(0))
end

function Wheel()
    print("Wheel")
end

function Clicker()
--print(BlzGetTriggerPlayerMouseX().." "..BlzGetTriggerPlayerMouseY())
    if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_LEFT then
        --print("LMB: "..BlzGetTriggerPlayerMouseX().." "..BlzGetTriggerPlayerMouseY())
        MakeShot(BlzGetTriggerPlayerMouseX(), BlzGetTriggerPlayerMouseY())
    end
    if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_RIGHT then
        --print("RMB: "..BlzGetTriggerPlayerMouseX().." "..BlzGetTriggerPlayerMouseY())
        ChainHook()
    end
end

function Releaser()
    if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_LEFT then
        print("leftmb off")
        --TimerStart(CreateTimer(), 0.05, false, function()
            BlzFrameSetEnable(ClickBlocker, false)
            --DestroyTimer(GetExpiredTimer())
        --end)
        ForceUICancelBJ(Player(0))
    end
end


function InitCameraScrollBar()
    -- create a vertical slider by inheriting from a Scrollbar. It will use esc menu textures
    local sliderFrame = BlzCreateFrameByType( "SLIDER", "TestSlider", BlzGetFrameByName("ConsoleUIBackdrop", 0), "QuestMainListScrollBar", 0 )
    -- clear the inherited attachment
    BlzFrameClearAllPoints(sliderFrame)
    -- set pos and size
    BlzFrameSetLevel(sliderFrame, 3)
    BlzFrameSetAbsPoint(sliderFrame, FRAMEPOINT_CENTER, 0.92, 0.30 )
    BlzFrameSetSize(sliderFrame, 0.014, 0.1 )
    -- define the area the user can choose from
    BlzFrameSetMinMaxValue(sliderFrame, 0, 80)
    -- how accurate the user can choose value
    BlzFrameSetStepSize(sliderFrame, 20)
    BlzFrameSetValue(sliderFrame, 40)

    local trigger = CreateTrigger()

    -- register the Slider Event
    BlzTriggerRegisterFrameEvent(trigger, sliderFrame, FRAMEEVENT_SLIDER_VALUE_CHANGED)

    -- this happens when the Slider is pushed
    TriggerAddAction(trigger, function()
        local frame = BlzGetTriggerFrame()
        --print(BlzFrameGetName(frame), "new Value", BlzGetTriggerFrameValue())
        SetGameCamera(BlzGetTriggerFrameValue())

    end)

    -- scorllable with mousewheel
    local triggerWheel = CreateTrigger()
    -- register the Mouse Wheel Event for the Slider
    BlzTriggerRegisterFrameEvent(triggerWheel, sliderFrame, FRAMEEVENT_MOUSE_WHEEL)
    -- this happens when the Mouse wheel is rolled while it points at the slider
    TriggerAddAction(triggerWheel, function()

        -- BlzGetTriggerFrameValue() tells us in which direction the wheel was rolled
        local add
        if BlzGetTriggerFrameValue() > 0 then
            add = 20
        else
            add = -20
        end

        -- the scrolling should only affect the triggering Player
        if GetLocalPlayer() == GetTriggerPlayer() then
            BlzFrameSetValue(sliderFrame, BlzFrameGetValue(sliderFrame) + add)
        end
    end)
end
function SetUnitFaceToCursor()
    local x = BlzGetTriggerPlayerMouseX()
    local y = BlzGetTriggerPlayerMouseY()

    local ux, uy = GetUnitPosition(slayer)
    --local angle = CalculateAngle(ux, uy, x, y)
    --SetUnitFacing(slayer, angle*180/math.pi)
    --SetUnitPositionWithFacing(slayer, ux, uy, angle)
    local posx, posy = FindCenterRayIntersection(ux, uy, x, y, 256)
    SetUnitPosition(posdummy, posx, posy)
end

function FixPosition()

    --нужно сдвигать даммика на случай если курсор не двигается
    --костыль, и работает не очень хорошо
    --можно попробовать сдлать отдельный таймер с маленьким периодом, 1/64 или меньше
    local slayerX, slayerY = GetUnitPosition(slayer)
    local distance = CalculateDistance(slayerX, slayerY, globalX, globalY)
    globalX = slayerX
    globalY = slayerY

    if distance > 0 then
        local dummyX, dummyY = GetUnitPosition(posdummy)
        local x, y = GetPointOnLine(slayerX, slayerY, dummyX, dummyY, CalculateDistance(slayerX, slayerY, dummyX, dummyY)+125)
        local x2, y2 = MovePoint(slayerX, slayerY, dummyX, dummyY, x, y)
        SetUnitPosition(posdummy, x2, y2)
    end
end

function _(code)
    return FourCC(code)
end

function GetUnitPosition(u)
    local x = GetUnitX(u)
    local y = GetUnitY(u)
    return x, y
end

function SetUnitPositionWithFacing(u, x, y, angle)
    SetUnitX(u, x)
    SetUnitY(u, y)
    SetUnitFacing(u, angle*180/math.pi)
end


function CreateTextFrame(frame, topleftX, topleftY, botrightX, botrightY, level, text, scale)
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_TOPLEFT, topleftX, topleftY)
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_BOTTOMRIGHT, botrightX, botrightY)
    BlzFrameSetLevel(frame, level)
    BlzFrameSetText(frame, text)
    BlzFrameSetEnable(frame, false)
    BlzFrameSetScale(frame, scale)
    BlzFrameSetTextAlignment(frame, TEXT_JUSTIFY_CENTER, TEXT_JUSTIFY_MIDDLE)
end

function FindClosestUnit(units, x, y)
    local closestUnit = nil
    local closestDistance = math.huge
    for i, unit in ipairs(units) do
        local unitX, unitY = GetUnitPosition(unit)
        local distance = CalculateDistance(unitX, unitY, x, y)
        if distance < closestDistance then
            closestUnit = unit
            closestDistance = distance
        end
    end
    return closestUnit
end

function Shuffle (arr)
    for i = 1, #arr - 1 do
        local j = math.random (i, #arr)
        arr [i], arr [j] = arr [j], arr [i]
    end
end
function CalculateAngleAndDistance(x1, y1, x2, y2)
    --возвращает угол в радианах и расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return angle, distance
end

function CalculateAngle(x1, y1, x2, y2)
    --возвращает угол в радианах между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    return angle
end

function CalculateDistance(x1, y1, x2, y2)
    --возвращает расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return distance
end

function FindIntersection(x1, y1, x2, y2)
    --возвращает точку пересечения луча, проходящего через две произвольных точки внутри окружности, с этой окружностью
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx^2 + dy^2
    local b = 2 * (dx * (x1 - CenterX) + dy * (y1 - CenterY))
    local c = CenterX^2 + CenterY^2 + x1^2 + y1^2 - 2 * (CenterX * x1 + CenterY * y1) - Radius^2
    local bb4ac = b^2 - 4 * a * c
    if bb4ac < 0 then
        return nil
    end
    local mu = (-b + math.sqrt(bb4ac)) / (2 * a)
    local ix1 = x1 + mu * dx
    local iy1 = y1 + mu * dy
    mu = (-b - math.sqrt(bb4ac)) / (2 * a)
    local ix2 = x1 + mu*dx
    local iy2 = y1 + mu*dy

    if (ix1-x1)*(ix2-x1) > 0 or (iy1-y1)*(iy2-y1) > 0 then
        return nil
    end

    return ix1, iy1
end

function FindCenterRayIntersection(x1, y1, x2, y2, radius)
    --возвращает точку пересечения луча, проходящего через центр окружности и произвольную точку, с этой окружностью
    local angle = CalculateAngle(x1, y1, x2, y2)
    local x3 = x1 + radius * math.cos(angle)
    local y3 = y1 + radius * math.sin(angle)
    return x3, y3
end

--function GetPointsOnLine(x1, y1, x2, y2, d)
  --  local points = {}
   -- local k = (y2 - y1) / (x2 - x1)
  --  local b = y1 - k * x1
  --  local dx = d / math.sqrt(1 + k * k)
  --  local x = x1 + dx
   -- local y = k * x + b
  --  while (x2 > x1 and x < x2) or (x2 < x1 and x > x2) do
   --     table.insert(points, {x = x, y = y})
  --      x = x + dx
   --     y = k * x + b
  --  end
  --  return points
--end

function GetPointsOnLine(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)
    for i = 1, steps+1 do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        table.insert(points, {x = x, y = y})
    end
    table.insert(points, {x = x2, y = y2})
    return points
end

function GetPointsOnLineWithRotation(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки, а также рандомные значения вращения
    --с pitch возникает какой-то баг, если задавать через SetPitch
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)

    local startYaw = math.random(-math.pi, math.pi)
    local endYaw = math.random(-math.pi, math.pi)
    local startPitch = math.random(-math.pi, math.pi)
    local endPitch = math.random(-math.pi, math.pi)
    local startRoll = math.random(-math.pi, math.pi)
    local endRoll = math.random(-math.pi, math.pi)

    for i = 1, steps+1 do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        local yaw = startYaw + (endYaw - startYaw) * t
        local pitch = startPitch + (endPitch - startPitch) * t
        local roll = startRoll + (endRoll - startRoll) * t
        table.insert(points, {x = x, y = y, yaw = yaw, pitch = pitch, roll = roll})
    end

    table.insert(points, {x = x2, y = y2, yaw = endYaw, pitch = endPitch, roll = endRoll})
    return points
end

function GetPointOnLine(x1, y1, x2, y2, d)
    --возвращает точку на луче, удалённую от начальной точки на расстояние d
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    --local dist = CalculateDistance(x1, y1, x2, y2)
    local t = d / dist
    local x = x1 + dx * t
    local y = y1 + dy * t
    return x, y
end


function RayCircleIntersection(x1, y1, x2, y2, x3, y3, r)
    --возвращает первую точку пересечения луча с окружностью. Иначе возвращает nil
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx * dx + dy * dy
    local b = 2 * (dx * (x1 - x3) + dy * (y1 - y3))
    local c = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3) - r * r
    local disc = b * b - 4 * a * c
    if disc < 0 then
        return nil
    else
        local t1 = (-b + math.sqrt(disc)) / (2 * a)
        local t2 = (-b - math.sqrt(disc)) / (2 * a)
        if t1 >= 0 and (t2 < 0 or t1 < t2) then
            return x1 + t1 * dx, y1 + t1 * dy
        elseif t2 >= 0 then
            return x1 + t2 * dx, y1 + t2 * dy
        else
            return nil
        end
    end
end

function IsPointInCircle(x1, y1, x2, y2, r)
    --возвращает true, если точка находится в окружности с центром (x2, y2) и радиусом r
    local distance = CalculateDistance(x1, y1, x2, y2, r)
    return distance < r
end

function QuadraticBezier(z1, z2, z3, t)
    --возвращает значение координаты на кривой безье
    local u = 1 - t
    local tt = t * t
    local uu = u * u
    local z = uu * z1 + 2 * u * t * z2 + tt * z3
    return z
end

function ComputePath(x1, y1, z1, x3, y3, z3, z2, d)
    --возвращает таблицу значений координат полёта снаряда
    local dx = x3 - x1
    local dy = y3 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local n = math.ceil(distance / d)

    local path = {}

    for i = 0, n do
        local t = i / n

        local x = x1 + t * (x3 - x1)
        local y = y1 + t * (y3 - y1)
        local z = QuadraticBezier(z1,z2,z3,t)

        table.insert(path, {x = x, y = y, z = z})
    end

    return path
end

function RandomPointInCircle(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return {x, y}
end

function RandomPointInCircleXY(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return x, y
end

function IsCirclesIntersect(x1, y1, r1, x2, y2, r2)
    --возвращает true если две окржуности пересекаются
    local dx = x2 - x1
    local dy = y2 - y1
    local distance = math.sqrt(dx * dx + dy * dy)
    return distance < r1 + r2
end

function RotatePoints(centerX, centerY, radius, step)
    --возвращает таблицу значений x,y для вращения четырёх точек по окружности
    local points = {{},{},{},{}}
    for angle = 0, 360, step do
        local radians = math.rad(angle)
        for i = 1, 4 do
            local x = centerX + radius * math.cos(radians + math.pi/2 * (i-1))
            local y = centerY + radius * math.sin(radians + math.pi/2 * (i-1))
            table.insert(points[i], {x, y})
        end
    end
    return points
end

function MovePoint(x1, y1, x2, y2, x3, y3)
    local angle = CalculateAngleAndDistance(x1, y1, x2, y2)
    local dist = CalculateDistance(x1, y1, x3, y3)
    local newX3 = x1 + dist * math.cos(angle)
    local newY3 = y1 + dist * math.sin(angle)
    return newX3, newY3
end
function PlayImpaleSound()
    PlaySound("Abilities/Spells/Undead/Impale/ImpaleHit.flac")
end

function PlayBrokenChain()
    PlaySound("Units/Human/SteamTank/SteamTankAttack1")
end

function PlayChain()
    PlaySound("sounds\\chain.flac")
end

function PlayStoneSound1(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound2(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath2.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound3(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath3.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSoundMain(x, y)
    local t = {PlayStoneSound1, PlayStoneSound2, PlayStoneSound3}
    local n = math.random(#t)
    t[n](x, y)
end

function PlayPainSound1()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound2()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound3()
    local snd = CreateSound("sounds\\Pain3",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound4()
    local snd = CreateSound("sounds\\Pain4",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound5()
    local snd = CreateSound("sounds\\Pain5",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSoundMain()
    local foos = {PlayPainSound1, PlayPainSound2, PlayPainSound3, PlayPainSound4, PlayPainSound5}
    local n = math.random(#foos)
    foos[n]()
end

function PlayImpaleMarkerSound(x, y)
    local snd = CreateSound("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 10)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end
function GotDamage()
    print("got damage")
    PlayPainSoundMain()
end


function ControlDmg(unit)
    SetUnitState(unit, UNIT_STATE_LIFE, GetUnitState(unit, UNIT_STATE_LIFE) - 25)
end

function CheckFireballDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 50) then
        GotDamage()
    end
    return
end


function CheckStoneDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 32, x, y, 60) then
        GotDamage()
        return true
    else
        return false
    end
end

function InitDamageTrigger()
    local DamageTrigger = CreateTrigger()
    TriggerRegisterUnitEvent(DamageTrigger, slayer, EVENT_UNIT_DAMAGED)
    TriggerAddCondition(DamageTrigger, Condition(ResetAfterDamage))
end

function ResetAfterDamage()
    GotDamage()
    SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
    SetUnitState(slayer, UNIT_STATE_LIFE, GetUnitState(slayer, UNIT_STATE_MAX_LIFE))
end




RealGetUnitX = GetUnitX
RealGetUnitY = GetUnitY


function GetUnitRealX(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitX(unit) - 16. end
    end

    return RealGetUnitX(unit)
end

function GetUnitRealY(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitY(unit) - 16. end
    end

    return RealGetUnitY(unit)
end

function CreateBoss()
    boss = CreateUnit(Player(1), _('Uanb'), 0, 0, bj_UNIT_FACING)
    SetHeroLevel(boss, 10, false)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitInvulnerable(boss, true)
    print("works")
end

function TripleImpale(d)
    print("triple impale")

    local targetX, targetY = GetUnitPosition(slayer)
    local target1 = {targetX, targetY}

    local casterX, casterY = GetUnitPosition(boss)
    local casterX, casterY = GetPointOnLine(casterX, casterY, targetX, targetY, 80)


    local angle, distance = CalculateAngleAndDistance(casterX, casterY, targetX, targetY)
    SetUnitFacing(boss, angle*180 / math.pi)
    SetUnitAnimationByIndex(boss, 7)

    local leftAngle = angle + math.rad(d)
    local rightAngle = angle - math.rad(d)

    local target1X = casterX + distance * math.cos(leftAngle)
    local target1Y = casterY + distance * math.sin(leftAngle)
    local target2 = {target1X, target1Y}

    local target2X = casterX + distance * math.cos(rightAngle)
    local target2Y = casterY + distance * math.sin(rightAngle)
    local target3 = {target2X, target2Y}

    local targets = {target1, target2, target3}
    local angles = {angle, leftAngle, rightAngle}
    local points = {}
    local endpoints = {}

    for i = 1, #impaleCasters do
        local endpointX, endpointY = FindIntersection(casterX, casterY, targets[i][1], targets[i][2])
        table.insert(endpoints, i, {endpointX, endpointY})
        local trueDistance = CalculateDistance(casterX, casterY, endpointX, endpointY)
        local impspll = BlzGetUnitAbility(impaleCasters[i], _('AUim'))
        BlzSetAbilityRealLevelField(impspll, ABILITY_RLF_WAVE_DISTANCE, 0, trueDistance)
        SetUnitPositionWithFacing(impaleCasters[i], casterX, casterY, angles[i])
        local linePoints = GetPointsOnLine(casterX, casterY, endpointX, endpointY, 100)
        table.insert(points, i, linePoints)


    end
    print(GetUnitPosition(impaleCasters[1]))

    local effects = {}
    local iTable = {1, 1, 1}
    for l = 1, 3 do
        TimerStart( CreateTimer(), 1/#points[l], true, function()
            eff = AddSpecialEffect("models\\redtriangle3", points[l][iTable[l]].x, points[l][iTable[l]].y)
            BlzSetSpecialEffectYaw( eff, angles[l] )
            PlayImpaleMarkerSound(points[l][iTable[l]].x, points[l][iTable[l]].y)
            table.insert(effects, eff)

            iTable[l] = iTable[l] + 1
            if iTable[l] == #points[l] then
                PauseTimer(GetExpiredTimer())
                DestroyTimer(GetExpiredTimer())
            end
        end)
    end

    local castDelay = CreateTimer()
    TimerStart(castDelay, 0.75, false, function()


        IssuePointOrder(dummy1, "impale", endpoints[1][1], endpoints[1][2])

        IssuePointOrder(dummy2, "impale", endpoints[2][1], endpoints[2][2])

        IssuePointOrder(dummy3, "impale", endpoints[3][1], endpoints[3][2])


        local t1 = CreateTimer()
        TimerStart(t1, 0.4, false, function()
            CameraSetEQNoiseForPlayer( Player(0), 30.00 )
            PlayImpaleSound()
            DestroyTimer(t1)
        end)

        local t2 = CreateTimer()
        TimerStart(t2, 0.65, false, function()
            CameraClearNoiseForPlayer( Player(0) )
            print(#effects)
            for e = 1, #effects do
                DestroyEffect(effects[e])
            end
            DestroyTimer(t2)
        end)

        local t = CreateTimer()
        TimerStart(t, 0.75, false, function()
            for i = 1, 3 do
                SetUnitPosition(impaleCasters[i], -1500, -1500)
            end
            DestroyTimer(t)
        end)
        DestroyTimer(castDelay)
    end)
end

function FireBall(startX, startY, endX, endY)
    --local angle = CalculateAngle(startX, endX, GetUnitX(slayer), GetUnitY(slayer))
    if IsPointInCircle(endX, endY, CenterX, CenterY, Radius) then
        --SetUnitFacing(boss, angle*180 / math.pi)
        SetUnitAnimationByIndex(boss, 7)
        local marker = AddSpecialEffect("models\\marker", endX, endY)
        BlzSetSpecialEffectScale(marker, 0.8)
        local maxZ = 820
        local startZ = 400
        local endZ = 220

        local points = ComputePath(startX, startY, startZ, endX, endY, endZ, maxZ, 30)
        local eff = AddSpecialEffect("Abilities\\Weapons\\FireBallMissile\\FireBallMissile", startX, startY)
        BlzSetSpecialEffectScale(eff, 1.5)
        local t = CreateTimer()
        local i = 1
        local sharp = #points

        TimerStart(t, 1/32, true, function()
            BlzSetSpecialEffectX(eff, points[i].x)
            BlzSetSpecialEffectY(eff, points[i].y)
            BlzSetSpecialEffectZ(eff, points[i].z)
            i = i + 1
            if i >= sharp then
                PauseTimer(t)
                CheckFireballDamage(points[i].x, points[i].y)
                DestroyEffect(marker)
                DestroyEffect(eff)
                DestroyTimer(t)
            end
        end)
    end
end

function FireBalls()
    local time = 0.15
    local bigCircleValue = 10
    local littleCircleValue = 20


    local startX, startY = GetUnitPosition(boss)
    local endX, endY = GetUnitPosition(slayer)

    local targets = {}
    table.insert(targets, {endX, endY})

    for i = 1, littleCircleValue do
        table.insert(targets, RandomPointInCircle(endX, endY, 600))
    end
    for ii = 1, bigCircleValue do
        table.insert(targets, RandomPointInCircle(CenterX, CenterY, Radius))
    end
    local t = CreateTimer()
    local a = 1
    TimerStart(t, time, true, function()
        FireBall(startX, startY, targets[a][1], targets[a][2])
        a=a+1
        if a > #targets then
            PauseTimer(t)
            DestroyTimer(t)
        end
    end)
end

function ThrowStone()
    local bx, by = GetUnitPosition(boss)
    local sx, sy = RandomPointInCircleXY(GetUnitX(slayer), GetUnitY(slayer), 400)
    local targetX, targetY = FindIntersection(bx, by, sx, sy)
    local points = GetPointsOnLineWithRotation(bx, by, targetX, targetY, 50)
    local eff = AddSpecialEffect("models\\Rock3", bx, by)
    BlzSetSpecialEffectScale(eff, 0.75)
    BlzSetSpecialEffectZ(eff, 350)


    local t = CreateTimer()
    local i = 1
    local sharp = #points
    TimerStart(t, 1/32, true, function()
        local pt = points[i]
        BlzSetSpecialEffectPosition(eff, pt.x,pt.y, 350)
        if CheckStoneDamage(pt.x, pt.y) then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSound()
            DestroyTimer(t)
        end
        --BlzSetSpecialEffectYaw(eff, pt.yaw)
        --BlzSetSpecialEffectPitch(eff, pt.pitch)
        --BlzSetSpecialEffectRoll(ff, pt.roll)
        BlzSetSpecialEffectOrientation(eff, pt.yaw, pt.pitch, pt.roll)
        i = i + 1
        if i > sharp then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSoundMain(pt.x, pt.y)
            DestroyTimer(t)
        end
    end)
end

function ThrowStones(duration)
    local points = RotatePoints(GetUnitX(boss), GetUnitY(boss), 200, 5)
    local t = {}
    for i = 1, 4 do
        local eff = AddSpecialEffect("models\\Rock3", points[i][1][1], points[i][1][2])
        BlzSetSpecialEffectScale(eff, 0.75)
        BlzSetSpecialEffectYaw(eff, math.random(1, 3))
        BlzSetSpecialEffectZ(eff, 350)
        table.insert(t, eff)
    end
    local rotateTimer = CreateTimer()
    local cd = CreateTimer()
    local waitDuration = CreateTimer()


    local n = 1
    local sharp = #points[1]
    TimerStart(rotateTimer, 1/32, true, function()
        for a = 1, 4 do
            BlzSetSpecialEffectPosition(t[a], points[a][n][1], points[a][n][2], 350)
        end
        if n == sharp then
            n = 2
        else
            n=n+1
        end
    end)
    TimerStart(cd, 0.5, true, function()
        ThrowStone()
    end)
    TimerStart(waitDuration, duration, false, function()
        PauseTimer(cd)
        DestroyTimer(cd)
        PauseTimer(rotateTimer)
        DestroyTimer(rotateTimer)
        for m = 1, #t do
            DestroyEffect(t[m])
        end
        DestroyTimer(waitDuration)
    end)
end


creeps = {}

function CreateTestUnit()
    local testUnit = CreateUnit(Player(1), _('hpea'), math.random(0, 800), math.random(0, 800), bj_UNIT_FACING)
    SetUnitPathing(testUnit, false)
    table.insert(creeps, testUnit)
end

function CreateDummy()
    local d = CreateUnit(Player(2), _('Dmmy'), -1500, -1500, bj_UNIT_FACING)
    SetHeroLevel(d, 10, false)
    SelectHeroSkill(d, _('AUim'))
    return d
end
function CreateSlayer()
    slayer = CreateUnit(Player(1), _('hrif'), 600, 200, bj_UNIT_FACING)
    SetUnitPathing(slayer, false)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitMoveSpeed(slayer, 522)
end

cooldown = false

function MakeShot(x, y)
    local startx, starty = GetUnitPosition(slayer)
    if IsPointInCircle(startx, starty, CenterX, CenterY, Radius - 20) then
        if not cooldown then
            --cooldown = true
            --local cooldownTimer = CreateTimer()
            --TimerStart(cooldownTimer, 0.2, false, function()
                --cooldown = false
            --end)
            local projectile = AddSpecialEffect("Abilities\\Weapons\\GyroCopter\\GyroCopterMissile", startx, starty)


            local targetx = BlzGetTriggerPlayerMouseX()
            local targety = BlzGetTriggerPlayerMouseY()

            local angle, distance = CalculateAngle(startx, starty, targetx, targety)
            BlzSetSpecialEffectYaw( projectile, angle )
            BlzSetSpecialEffectZ(projectile, 350)
            local endpointX, endpointY = FindIntersection(startx, starty, targetx, targety)
            local hitplaceX, hitplaceY = RayCircleIntersection(startx, starty, endpointX, endpointY, GetUnitX(boss), GetUnitY(boss), 120)

            local movePoints = GetPointsOnLine(startx, starty, endpointX, endpointY, 20)
            local sharp = #movePoints
            local i = 1
            local t = CreateTimer()
            if hitplaceX == nill then
                TimerStart(t, 1/64, true, function()
                    BlzSetSpecialEffectX(projectile, movePoints[i].x)
                    BlzSetSpecialEffectY(projectile, movePoints[i].y)
                    BlzSetSpecialEffectZ(projectile, 350)

                    for a = 1, #creeps do
                        local testX, testY = GetUnitPosition(creeps[a])
                        if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            ControlDmg(creeps[a])
                            DestroyTimer(t)
                        end
                    end
                    i = i+1
                    if i > sharp then
                        PauseTimer(t)
                        DestroyEffect(projectile)
                        DestroyTimer(t)
                    end
                end)
            else
                TimerStart(t, 1/64, true, function()
                    BlzSetSpecialEffectX(projectile, movePoints[i].x)
                    BlzSetSpecialEffectY(projectile, movePoints[i].y)
                    BlzSetSpecialEffectZ(projectile, 350)
                    local d = CalculateDistance(movePoints[i].x, movePoints[i].y, hitplaceX, hitplaceY)
                    local testX, testY = GetUnitPosition(testUnit)
                    for a = 1, #creeps do
                        local testX, testY = GetUnitPosition(creeps[a])
                        if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            ControlDmg(creeps[a])
                            DestroyTimer(t)
                        end
                    end
                    if d <= 10 then
                        PauseTimer(t)
                        DestroyEffect(projectile)
                        DestroyTimer(t)
                    end
                    i = i+1
                    if i > sharp then
                        PauseTimer(t)
                        DestroyEffect(projectile)
                        DestroyTimer(t)
                    end
                end)
            end
        end
    end
end

function Sawing()
    local targets = {}
    local x, y = GetUnitPosition(slayer)


    local target = FindClosestUnit(creeps, x, y)
    local tX, tY = GetUnitPosition(target)
    if IsPointInCircle(tX, tY, x, y, 350) then
        SetUnitPosition(slayer, tX, tY)
        CameraSetFocalDistance(50)
    end
end

function Dash()
    local distance = 400
    --local mouseX = BlzGetTriggerPlayerMouseX()
    --local mouseY = BlzGetTriggerPlayerMouseY()
    local mouseX, mouseY = GetUnitPosition(posdummy)

    local slayerX, slayerY = GetUnitPosition(slayer)

    local x, y = GetPointOnLine(slayerX, slayerY, mouseX, mouseY, distance)

    local points = GetPointsOnLine(slayerX, slayerY, x, y, 40)
    local i = 1
    local sharp = #points

    local t = CreateTimer()
    TimerStart(t, 1/64, true, function()
        local p = points[i]
        SetUnitPosition(slayer, p.x, p.y)
        SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
        i = i + 1
        if i > sharp then
            DestroyTimer(t)
        end
    end)
end

Chaining = false
function ChainHook()
    if not Chaining then
        local function MoveToTheTarget(points, effects, sharp)
            local i = 1
            local t2 = CreateTimer()
            TimerStart( t2, 1/64, true, function()
                p = points[i]
                DestroyEffect(effects[i])
                print(p.x.." "..p.y)
                if IsPointInCircle(p.x, p.y, CenterX, CenterY, Radius) then
                    SetUnitPosition(slayer, p.x, p.y)
                end
                i = i + 1
                if i > sharp - 8 then
                    Chaining = false
                end
                if i > sharp then
                    PauseTimer(t2)
                    EnableTrigger(ClickTrigger)
                    --PauseUnit(slayer, false)
                    SetUnitMoveSpeed(slayer, 522)
                    Chaining = false
                    DestroyTimer(t2)
                end
            end)
        end


        local targets = {}
        local cursorX = BlzGetTriggerPlayerMouseX()
        local cursorY = BlzGetTriggerPlayerMouseY()
        local x, y = GetUnitPosition(slayer)


        local target = FindClosestUnit(creeps, cursorX, cursorY)
        local tX, tY = GetUnitPosition(target)


        if IsPointInCircle(tX, tY, x, y, 1000) and IsPointInCircle(tX, tY, cursorX, cursorY, 150) then
            Chaining = true
            print("chaining")
            DisableTrigger(ClickTrigger)
            PlayChain()
            --PauseUnit(slayer, true)
            SetUnitMoveSpeed(slayer, 0)
            IssueImmediateOrder(slayer, "stop")
            local x1, y1 = GetPointOnLine(tX, tY, x, y, 36)
            local points = GetPointsOnLine(x, y, x1, y1, 34)
            table.remove(points, #points)
            local i = 1
            local sharp = #points
            local angle = CalculateAngle(x, y, x1, y1)
            local t = CreateTimer()
            local effects = {}

            TimerStart( t, 1/64, true, function()
                --IssueImmediateOrder(slayer, "stop") --kek
                p = points[i]
                eff = AddSpecialEffect("models\\chainlink", p.x, p.y)
                BlzSetSpecialEffectYaw( eff, angle )
                table.insert(effects, eff)

                i = i + 1
                if i > sharp then
                    PauseTimer(t)
                    MoveToTheTarget(points, effects, sharp)
                    DestroyTimer(t)
                end
            end)
            --SetUnitPosition(slayer, x1, y1)
        else
            PlayBrokenChain()
        end
    end
end
--CUSTOM_CODE
function InitCustomPlayerSlots()
SetPlayerStartLocation(Player(0), 0)
SetPlayerColor(Player(0), ConvertPlayerColor(0))
SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
SetPlayerRaceSelectable(Player(0), true)
SetPlayerController(Player(0), MAP_CONTROL_USER)
end

function InitCustomTeams()
SetPlayerTeam(Player(0), 0)
end

function main()
SetCameraBounds(-5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
NewSoundEnvironment("Default")
SetAmbientDaySound("NorthrendDay")
SetAmbientNightSound("NorthrendNight")
SetMapMusic("Music", true, 0)
InitBlizzard()
InitGlobals()
end

function config()
SetMapName("TRIGSTR_001")
SetMapDescription("TRIGSTR_003")
SetPlayers(1)
SetTeams(1)
SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
DefineStartLocation(0, 0.0, 0.0)
InitCustomPlayerSlots()
SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
InitGenericPlayerSlots()
end

