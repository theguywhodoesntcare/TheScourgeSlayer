function InitGlobals()
end

--CUSTOM_CODE
do
    local real = MarkGameStarted
    function MarkGameStarted()
        FogMaskEnableOff()
        FogEnableOff()
        UseTimeOfDayBJ(false)
        CinematicFilterGenericBJ( 2, BLEND_MODE_BLEND, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 100, 100, 100, 0.00, 100.00, 100.00, 100.00, 0.00 )
        StatusList()
        InitCustomUI()
        math.randomseed(os.time())
        GetUnitX = GetUnitRealX
        GetUnitY = GetUnitRealY
        CreateBoss()
        for i = 1, maxcreeps do
            CreateTestUnit()
        end
        dummy1 = CreateDummy()
        dummy2 = CreateDummy()
        dummy3 = CreateDummy()
        posdummy = CreateDummy()
        impaleCasters = {dummy1, dummy2, dummy3}
        --BlzHideOriginFrames(true)
        CreateSlayer()
        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        globalX, globalY = GetUnitPosition(slayer)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 200, true)
        StopMusicBJ( false )
        ClearMapMusicBJ(  )

        CreateBarrier()
        InitCameraScrollBar()
        CreateBlood()
        CreateBones()


        local text = "|cffffffffMovement — [|cffffff00W|r][|cffffff00A|r][|cffffff00S|r][|cffffff00D|r]\n\nShooting — |cffffff00Left Mouse Button|r\n\nDash — [|cffffff00SPACE|r]\n\nChain — |cffffff00Right Mouse Button|r\n\nSAW THE UNDEAD BASTARD — [|cffff0000E|r]\n\nHave fun!|r"
        local descr = CreateText(consoleFrame, 0.4, 0.3, 0.4, text, 2)
        BlzFrameSetScale(descr, 3)
        BossFight(descr)
    end
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 14.05.2023 20:47
---
function SetGameCamera(preset)
    if preset == 40 then
        ResetToGameCamera( 1 )
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 200, true)
    end
    if preset == 60 then
        local t = {1480, 4800, 16, 310, 62, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 80 then
        local t = {800, 4000, 16, 338.045, 30.0027917027, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 0 then
        local t = {3000, 5400, 16, 304, 90, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
    if preset == 20 then
        local t = {2400, 5400, 16, 304, 80, 1.570796, 20}
        local d = 2
        SetCameraFields(t, d)
        SetCameraTargetControllerNoZForPlayer(Player(0), slayer, 0, 0, true)
    end
end

function SetCameraFields(t, d)
    SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, t[1], d)
    SetCameraField(CAMERA_FIELD_FARZ, t[2], d)
    SetCameraField(CAMERA_FIELD_NEARZ, t[3], d)
    SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, t[4], d)
    SetCameraField(CAMERA_FIELD_FIELD_OF_VIEW, t[5], d)
    SetCameraField(CAMERA_FIELD_ROTATION, t[6])
    SetCameraField(CAMERA_FIELD_ZOFFSET, t[7])
    --------------------
    SetCameraField(CAMERA_FIELD_ROLL, 0.0)
    SetCameraField(CAMERA_FIELD_LOCAL_PITCH, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_YAW, 0)
    SetCameraField(CAMERA_FIELD_LOCAL_ROLL, 0)
end

function InitControlKeys()

    KeyTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_Q, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_V, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_E, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_SPACE, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(KeyTrigger, GetLocalPlayer(), OSKEY_O, 0, true)
    TriggerAddCondition(KeyTrigger, Condition(ControlKeys))

    ------MOVING SYSTEM------
    orders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица текущих направлений
    futureOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --таблица будущих направлений, нужно хранить, чтобы можно было быстро перемещаться в противоположную сторону
    additionalOrders = {Xp = 0; Xm = 0; Yp = 0; Ym = 0} --нужна для хранения направлений, заданных кратковременными нажатиями, и не попавших в основные из-за тика таймера

    Apressed = false
    Wpressed = false
    Spressed = false
    Dpressed = false

    ButtonPressedTrigger = CreateTrigger()
    ButtonReleasedTrigger = CreateTrigger()

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_A, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_A, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_W, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_W, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_S, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_S, 0, false)

    BlzTriggerRegisterPlayerKeyEvent(ButtonPressedTrigger, GetLocalPlayer(), OSKEY_D, 0, true)
    BlzTriggerRegisterPlayerKeyEvent(ButtonReleasedTrigger, GetLocalPlayer(), OSKEY_D, 0, false)

    TriggerAddCondition(ButtonPressedTrigger, Condition(ButtonPressed))
    TriggerAddCondition(ButtonReleasedTrigger, Condition(ButtonReleased))
    InitWalkTimer()
end
function InitWalkTimer()
    local acidCounter = 0
    walkTimer = CreateTimer()
    TimerStart(walkTimer, 1/16, true, function()
        local ux, uy = GetUnitPosition(slayer)
        if (Apressed or Wpressed or Dpressed or Spressed) and not Chaining then --and not (Apressed and Dpressed) and not (Wpressed and Spressed))
            --local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            --local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            if orders.Xm == 300 and orders.Xp == 300 then
                if not Apressed then
                    orders.Xm = 0
                end
                if not Dpressed then
                    orders.Xp = 0
                end
            end
            if orders.Ym == 300 and orders.Yp == 300 then
                if not Spressed then
                    orders.Ym = 0
                end
                if not Wpressed then
                    orders.Yp = 0
                end
            end

            --local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            if not sawing then
                if not CageOn then
                    IssuePointOrder(slayer, "move", x, y)
                    FixCursor(ux, uy)
                elseif SlayerInsideCage then
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if not IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                else
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                end
            end
            --print(orders.Xm.." "..orders.Xp.." "..orders.Ym.." "..orders.Yp.." "..x.." "..y.." "..ux.." "..uy)
        elseif --(not Apressed and not Wpressed and not Dpressed and not Spressed) and
        (additionalOrders.Xm ~= 0 or additionalOrders.Xp ~= 0 or additionalOrders.Ym ~= 0 or additionalOrders.Yp ~= 0) and not Chaining then
            --print("additional condition")
            for k, v in pairs(additionalOrders) do
                if v ~= 0 then
                    orders[k] = v
                    additionalOrders[k] = 0
                end
            end
            local x = GetUnitX(slayer) + orders.Xm + orders.Xp
            local y = GetUnitY(slayer) + orders.Ym + orders.Yp
            --local ux, uy = GetUnitPosition(slayer)
            local x = ux - orders.Xm + orders.Xp
            local y = uy - orders.Ym + orders.Yp
            if not sawing then
                if not CageOn then
                    IssuePointOrder(slayer, "move", x, y)
                    FixCursor(ux, uy)
                elseif SlayerInsideCage then
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if not IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                else
                    local xx, yy = GetPointOnLine(ux, uy, x, y, 80)
                    if IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                    else
                        IssuePointOrder(slayer, "move", x, y)
                        FixCursor(ux, uy)
                    end
                end
            end
        else
            orders.Xm = 0
            orders.Yp = 0
            orders.Xp = 0
            orders.Ym = 0
            IssueImmediateOrder(slayer, "stop")
        end
        if acidGlobal then
            local sharp = #puddles
            for p = 1, sharp do
                if IsPointInCircle(ux, uy, puddles[p].x, puddles[p].y, 90) then
                    acidCounter = acidCounter + 1
                    if acidCounter >= 2 then
                        GotDamage("acid")
                        acidCounter = 0
                    end
                    break
                end
            end
        end
        if fuelOnMap then
            local sharpF = #fuel
            for f = 1, sharpF do
                local fuelX = fuel[f][1][1]
                local fuelY = fuel[f][1][2]
                if IsPointInCircle(ux, uy, fuelX, fuelY , 80) then
                    --print(fuelX)
                        PickFuel(fuel[f], f)
                    break
                end
            end
        end
        if chargesOnMap then
            local sharpC = #dashChargesItems
            for c = 1, sharpC do
                local chargeX = dashChargesItems[c][1][1]
                local chargeY = dashChargesItems[c][1][2]
                if IsPointInCircle(ux, uy, chargeX, chargeY , 80) then
                    --print(chargeX)
                    PickCharge(dashChargesItems[c], c)
                    break
                end
            end
        end
        if Stage == 1 then
            local incircle = IsPointInCircle(ux, uy, CenterX, CenterY, Radius)
            if not incircle and not safetyZone then
                safetyZone = true
                SetUnitInvulnerable(slayer, true)
                --print("safety zone")
                Safety()
            elseif incircle and safetyZone then
                safetyZone = false
                SetUnitInvulnerable(slayer, false)
                --print("battllefield")
            end
        end
    end)
end

function ButtonPressed()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = true
        if Dpressed == false then
            orders.Xm = 300
            additionalOrders.Xm = 300
        else
            futureOrders.Xm = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = true
        if Spressed == false then
            orders.Yp = 300
            additionalOrders.Yp = 300
        else
            futureOrders.Yp = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = true
        if Wpressed == false then
            orders.Ym = 300
            additionalOrders.Ym = 300
        else
            futureOrders.Ym = 300
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = true
        if Apressed == false then
            orders.Xp = 300
            additionalOrders.Xp = 300
        else
            futureOrders.Xp = 300
        end
    end
end

function ButtonReleased()
    if BlzGetTriggerPlayerKey() == OSKEY_A then
        Apressed = false
        orders.Xm = 0
        if futureOrders.Xp ~= 0 then
            orders.Xp = futureOrders.Xp
            futureOrders.Xp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_W then
        Wpressed = false
        orders.Yp = 0
        if futureOrders.Ym ~= 0 then
            orders.Ym = futureOrders.Ym
            futureOrders.Ym = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_S then
        Spressed = false
        orders.Ym = 0
        if futureOrders.Yp ~= 0 then
            orders.Yp = futureOrders.Yp
            futureOrders.Yp = 0
        end
    end
    if BlzGetTriggerPlayerKey() == OSKEY_D then
        Dpressed = false
        orders.Xp = 0
        if futureOrders.Xm ~= 0 then
            orders.Xm = futureOrders.Xm
            futureOrders.Xm = 0
        end
    end
end


function ControlKeys()
    if BlzGetTriggerPlayerKey() == OSKEY_Q then
        --print("Q")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        --TimerStart(CreateTimer(), 2, true, function()
            --FireBalls()
        --end)
    end
    if BlzGetTriggerPlayerKey() == OSKEY_E then
        --print("E")
        --IssuePointOrder(slayer, "move", GetUnitX(slayer), GetUnitY(slayer))
        --TripleImpale(30)
        Sawing()
    end
    if BlzGetTriggerPlayerKey() == OSKEY_V then
        CameraSetFocalDistance(0)
        --print("V")

        SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
        --ThrowStones(15)
        --TripleImpale(35)
        --CreateTestUnit()
        --Laser()
        --Acid(30)
        --Cage(500, 5)
        --CorpseBombs(10, 1)
       --BeetleLaunch()
        --Bugs()
        --CreateCharge()
    end

    if BlzGetTriggerPlayerKey() == OSKEY_SPACE then
        --print("SPACE")
        Dash()
    end
end

function TurnKeyTriggers(off)
    if off then
        DisableTrigger(KeyTrigger)
        DisableTrigger(ButtonPressedTrigger)
        DisableTrigger(ButtonReleasedTrigger)
    else
        EnableTrigger(KeyTrigger)
        EnableTrigger(ButtonPressedTrigger)
        EnableTrigger(ButtonReleasedTrigger)
    end
end
function InitControlMouse()
    MouseTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(MouseTrigger, Player(0), EVENT_PLAYER_MOUSE_MOVE)

    TriggerAddCondition(MouseTrigger, Condition(ControlMouse))

  ClickTrigger = CreateTrigger()
    TriggerRegisterPlayerEvent(ClickTrigger, Player(0), EVENT_PLAYER_MOUSE_DOWN)
    TriggerAddCondition(ClickTrigger, Condition(Clicker))


WheelTrigger = CreateTrigger()
    BlzTriggerRegisterFrameEvent(WheelTrigger, InfoBackground, FRAMEEVENT_MOUSE_WHEEL)
    TriggerAddAction(trigger, function()
        --print("wheel")
    end)
  ClickReleaseTrigger = CreateTrigger()
   TriggerRegisterPlayerEvent(ClickReleaseTrigger, Player(0), EVENT_PLAYER_MOUSE_UP)
   TriggerAddCondition(ClickReleaseTrigger, Condition(Releaser))

    chainMarker = false
    rmbpressed = false

end

function ControlMouse()
    SetUnitFaceToCursor()
end

function CancelClick()
    --print("world click")
    ForceUICancelBJ(Player(0))
end

function Wheel()
    --print("Wheel")
end

function Clicker()
    if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) and not sawing then
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_LEFT then
            MakeShot(BlzGetTriggerPlayerMouseX(), BlzGetTriggerPlayerMouseY())
        end
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_RIGHT then
            --local eff = AddSpecialEffect("models\\greencircle", BlzGetTriggerPlayerMouseX(), BlzGetTriggerPlayerMouseY())
            --table.insert(slayerEffects, eff)
            rmbpressed = true
            FindChainTarget()
        end
    end
end

function Releaser()
    if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) then
        if BlzGetTriggerPlayerMouseButton() == MOUSE_BUTTON_TYPE_RIGHT then
            rmbpressed = false
            ChainHook()
        end
    end
end


globalCursorX = 0
globalCursorY = 0

globalCursorXInit = 0
globalCursorYInit = 0


function SetUnitFaceToCursor()
    globalCursorX = BlzGetTriggerPlayerMouseX()
    globalCursorY = BlzGetTriggerPlayerMouseY()

    globalCursorXInit, globalCursorYInit = globalCursorX, globalCursorY

    local ux, uy = GetUnitPosition(slayer)
    globalX, globalY = ux, uy
    --local angle = CalculateAngle(ux, uy, x, y)
    --SetUnitFacing(slayer, angle*180/math.pi)
    --SetUnitPositionWithFacing(slayer, ux, uy, angle)
    local posx, posy = FindCenterRayIntersection(ux, uy, globalCursorX, globalCursorY, 256)
    SetUnitPosition(posdummy, posx, posy)
end


function FixCursor(localX, localY)
    local deltaX = localX - globalX
    local deltaY = localY - globalY

    if deltaX ~= 0 or deltaY ~= 0 then
        globalCursorX = globalCursorXInit + deltaX
        globalCursorY = globalCursorYInit + deltaY
    end

    local posx, posy = FindCenterRayIntersection(localX, localY, globalCursorX, globalCursorY, 256)
    SetUnitPosition(posdummy, posx, posy)
end
function _(code)
    return FourCC(code)
end

function HideDefaultUI()

        --local info_bar = BlzFrameGetChild(ORIGIN_FRAME_GAME_UI, 1)
        local gameui = BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
        BlzFrameSetVisible(BlzFrameGetChild(gameui, 1), false)
        BlzFrameSetAbsPoint(BlzGetFrameByName("ConsoleUIBackdrop", 0), FRAMEPOINT_TOPRIGHT, 0, 0)
        for i = 0, 11 do
            BlzFrameSetVisible(BlzGetFrameByName("CommandButton_" .. i, 0), false)
        end
        BlzHideOriginFrames(true)
        BlzFrameSetScale(BlzFrameGetChild(BlzGetFrameByName("ConsoleUI", 0), 5), 0.001)

end

function GetUnitPosition(u)
    local x = GetUnitX(u)
    local y = GetUnitY(u)
    return x, y
end

function SetUnitPositionWithFacing(u, x, y, angle)
    SetUnitX(u, x)
    SetUnitY(u, y)
    SetUnitFacing(u, angle*180/math.pi)
end


function CreateTextFrame(frame, topleftX, topleftY, botrightX, botrightY, level, text, scale) --old
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_TOPLEFT, topleftX, topleftY)
    BlzFrameSetAbsPoint(frame, FRAMEPOINT_BOTTOMRIGHT, botrightX, botrightY)
    BlzFrameSetLevel(frame, level)
    BlzFrameSetText(frame, text)
    BlzFrameSetEnable(frame, false)
    BlzFrameSetScale(frame, scale)
    BlzFrameSetTextAlignment(frame, TEXT_JUSTIFY_CENTER, TEXT_JUSTIFY_MIDDLE)
end

function FindClosestUnit(units, x, y)
    local closestUnit = nil
    local closestDistance = math.huge
    for i, unit in ipairs(units) do
        local unitX, unitY = GetUnitPosition(unit)
        local distance = CalculateDistance(unitX, unitY, x, y)
        if distance < closestDistance then
            closestUnit = unit
            closestDistance = distance
        end
    end
    return closestUnit
end

function Shuffle (arr)
    for i = 1, #arr - 1 do
        local j = math.random (i, #arr)
        arr [i], arr [j] = arr [j], arr [i]
    end
end

function CreateBackdrop(parent, centerX, centerY, size, texture, lvl)
    local fr = BlzCreateFrameByType("BACKDROP", "", parent, "", 1)
    BlzFrameSetLevel(fr, lvl)
    BlzFrameSetAbsPoint(fr, FRAMEPOINT_CENTER, centerX, centerY)
    BlzFrameSetSize(fr, size, size)
    BlzFrameSetTexture(fr, texture, 0, true)
    return fr
end

function CreateBackdropTwoPoints(parent, topleftX, topleftY, botrightX, botrightY, texture, lvl)
    local fr = BlzCreateFrameByType("BACKDROP", "", parent, "", 1)
    BlzFrameSetLevel(fr, lvl)
    BlzFrameSetAbsPoint(fr, FRAMEPOINT_TOPLEFT, topleftX, topleftY)
    BlzFrameSetAbsPoint(fr, FRAMEPOINT_BOTTOMRIGHT, botrightX, botrightY)
    BlzFrameSetTexture(fr, texture, 0, true)
    return fr
end

function CreateText(parent, centerX, centerY, size, text, lvl)
    local fr = BlzCreateFrameByType("TEXT", "", parent, "", 0)
    BlzFrameSetLevel(fr, lvl)
    BlzFrameSetAbsPoint(fr, FRAMEPOINT_CENTER, centerX, centerY)
    BlzFrameSetSize(fr, size, size)
    BlzFrameSetText(fr, text)
    BlzFrameSetEnable(fr, false)
    BlzFrameSetScale(fr, 1)
    BlzFrameSetTextAlignment(fr, TEXT_JUSTIFY_CENTER, TEXT_JUSTIFY_MIDDLE)
    return fr
end

function round(num, numDecimalPlaces)
    local mult = 10^(numDecimalPlaces or 0)
    return math.floor(num * mult + 0.5) / mult
end
function CalculateAngleAndDistance(x1, y1, x2, y2)
    --возвращает угол в радианах и расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return angle, distance
end

function CalculateAngle(x1, y1, x2, y2)
    --возвращает угол в радианах между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local angle
    if deltaX == 0 then
        if deltaY > 0 then
            angle = math.pi / 2
        else
            angle = -math.pi / 2
        end
    else
        angle = math.atan(deltaY / deltaX)
        if deltaX < 0 then
            angle = angle + math.pi
        end
    end

    return angle
end

function CalculateDistance(x1, y1, x2, y2)
    --возвращает расстояние между двумя точками
    local deltaX = x2 - x1
    local deltaY = y2 - y1

    local distance = math.sqrt(deltaX^2 + deltaY^2)
    return distance
end

function FindIntersection(x1, y1, x2, y2)
    --возвращает точку пересечения луча, проходящего через две произвольных точки внутри окружности, с этой окружностью
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx^2 + dy^2
    local b = 2 * (dx * (x1 - CenterX) + dy * (y1 - CenterY))
    local c = CenterX^2 + CenterY^2 + x1^2 + y1^2 - 2 * (CenterX * x1 + CenterY * y1) - Radius^2
    local bb4ac = b^2 - 4 * a * c
    if bb4ac < 0 then
        return nil
    end
    local mu = (-b + math.sqrt(bb4ac)) / (2 * a)
    local ix1 = x1 + mu * dx
    local iy1 = y1 + mu * dy
    mu = (-b - math.sqrt(bb4ac)) / (2 * a)
    local ix2 = x1 + mu*dx
    local iy2 = y1 + mu*dy

    if (ix1-x1)*(ix2-x1) > 0 or (iy1-y1)*(iy2-y1) > 0 then
        return nil
    end

    return ix1, iy1
end

function FindCenterRayIntersection(x1, y1, x2, y2, radius)
    --возвращает точку пересечения луча, проходящего через центр окружности и произвольную точку, с этой окружностью
    local angle = CalculateAngle(x1, y1, x2, y2)
    local x3 = x1 + radius * math.cos(angle)
    local y3 = y1 + radius * math.sin(angle)
    return x3, y3
end

function GetPointsOnLine(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)
    for i = 1, steps do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        table.insert(points, {x = x, y = y})
    end
    table.insert(points, {x = x2, y = y2})
    return points
end

function GetPointsOnLineWithRotation(x1, y1, x2, y2, d)
    --возвращает массив точек, делящих луч на отрезки, а также рандомные значения вращения
    --с pitch возникает какой-то баг, если задавать через SetPitch
    local points = {}
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    local steps = math.floor(dist / d)

    local startYaw = math.random(-math.pi, math.pi)
    local endYaw = math.random(-math.pi, math.pi)
    local startPitch = math.random(-math.pi, math.pi)
    local endPitch = math.random(-math.pi, math.pi)
    local startRoll = math.random(-math.pi, math.pi)
    local endRoll = math.random(-math.pi, math.pi)

    for i = 1, steps+1 do
        local t = i / steps
        local x = x1 + dx * t
        local y = y1 + dy * t
        local yaw = startYaw + (endYaw - startYaw) * t
        local pitch = startPitch + (endPitch - startPitch) * t
        local roll = startRoll + (endRoll - startRoll) * t
        table.insert(points, {x = x, y = y, yaw = yaw, pitch = pitch, roll = roll})
    end

    table.insert(points, {x = x2, y = y2, yaw = endYaw, pitch = endPitch, roll = endRoll})
    return points
end

function GetPointOnLine(x1, y1, x2, y2, d)
    --возвращает точку на луче, удалённую от начальной точки на расстояние d
    local dx = x2 - x1
    local dy = y2 - y1
    local dist = math.sqrt(dx * dx + dy * dy)
    --local dist = CalculateDistance(x1, y1, x2, y2)
    local t = d / dist
    local x = x1 + dx * t
    local y = y1 + dy * t
    return x, y
end


function RayCircleIntersection(x1, y1, x2, y2, x3, y3, r)
    --возвращает первую точку пересечения луча с окружностью. Иначе возвращает nil
    local dx = x2 - x1
    local dy = y2 - y1
    local a = dx * dx + dy * dy
    local b = 2 * (dx * (x1 - x3) + dy * (y1 - y3))
    local c = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3) - r * r
    local disc = b * b - 4 * a * c
    if disc < 0 then
        return nil
    else
        local t1 = (-b + math.sqrt(disc)) / (2 * a)
        local t2 = (-b - math.sqrt(disc)) / (2 * a)
        if t1 >= 0 and (t2 < 0 or t1 < t2) then
            return x1 + t1 * dx, y1 + t1 * dy
        elseif t2 >= 0 then
            return x1 + t2 * dx, y1 + t2 * dy
        else
            return nil
        end
    end
end

function IsPointInCircle(x1, y1, x2, y2, r)
    --возвращает true, если точка находится в окружности с центром (x2, y2) и радиусом r
    local distance = CalculateDistance(x1, y1, x2, y2, r)
    return distance < r
end

function QuadraticBezier(z1, z2, z3, t)
    --возвращает значение координаты на кривой безье
    local u = 1 - t
    local tt = t * t
    local uu = u * u
    local z = uu * z1 + 2 * u * t * z2 + tt * z3
    return z
end

function ComputePath(x1, y1, z1, x3, y3, z3, z2, d)
    --возвращает таблицу значений координат полёта снаряда
    local dx = x3 - x1
    local dy = y3 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local n = math.ceil(distance / d)

    local path = {}

    for i = 0, n do
        local t = i / n

        local x = x1 + t * (x3 - x1)
        local y = y1 + t * (y3 - y1)
        local z = QuadraticBezier(z1,z2,z3,t)

        table.insert(path, {x = x, y = y, z = z})
    end

    return path
end

function ComputePathWithRotation(x1, y1, z1, x3, y3, z3, z2, d)
    local dx = x3 - x1
    local dy = y3 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local n = math.ceil(distance / d)

    local path = {}

    local startYaw = math.random(-math.pi, math.pi)
    local endYaw = math.random(-math.pi, math.pi)
    local startPitch = math.random(-math.pi, math.pi)
    local endPitch = math.random(-math.pi, math.pi)
    local startRoll = math.random(-math.pi, math.pi)
    local endRoll = math.random(-math.pi, math.pi)

    for i = 0, n do
        local t = i / n

        local x = x1 + t * (x3 - x1)
        local y = y1 + t * (y3 - y1)
        local z = QuadraticBezier(z1,z2,z3,t)

        local yaw = startYaw + (endYaw - startYaw) * t
        local pitch = startPitch + (endPitch - startPitch) * t
        local roll = startRoll + (endRoll - startRoll) * t

        table.insert(path, {x = x, y = y, z = z, yaw = yaw, pitch = pitch, roll = roll})
    end

    return path
end

function RandomPointInCircle(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return {x, y}
end

function GetRandomPointOnCircle(centerX, centerY, radius)
    --возвращает случайную точку на окружности
    local angle = math.random() * math.pi * 2
    local x = centerX + radius * math.cos(angle)
    local y = centerY + radius * math.sin(angle)
    return x, y
end

function GetOppositePointOnCircle(centerX, centerY, pointX, pointY)
    --возвращает диаметрально противоположную точку на окружности
    local dx = centerX - pointX
    local dy = centerY - pointY
    local oppositeX = centerX + dx
    local oppositeY = centerY + dy
    return oppositeX, oppositeY
end

function RandomPointInCircleXY(xCenter, yCenter, radius)
    --возвращает случайную точку в пределах окружности
    local theta = math.random() * 2 * math.pi
    local r = math.sqrt(math.random()) * radius
    local x = xCenter + r * math.cos(theta)
    local y = yCenter + r * math.sin(theta)
    return x, y
end

function IsCirclesIntersect(x1, y1, r1, x2, y2, r2)
    --возвращает true если две окржуности пересекаются
    local dx = x2 - x1
    local dy = y2 - y1
    local distance = math.sqrt(dx * dx + dy * dy)
    return distance < r1 + r2
end

function RotatePoints(centerX, centerY, radius, step)
    --возвращает таблицу значений x,y для вращения четырёх точек по окружности
    local points = {{},{},{},{}}
    for angle = 0, 360, step do
        local radians = math.rad(angle)
        for i = 1, 4 do
            local x = centerX + radius * math.cos(radians + math.pi/2 * (i-1))
            local y = centerY + radius * math.sin(radians + math.pi/2 * (i-1))
            table.insert(points[i], {x, y})
        end
    end
    return points
end

function RotateDiameter(pointsDiameter, centerX, centerY, angle)
    --поворачивает диаметр на угол angle
    local newPoints = {}
    for i, point in ipairs(pointsDiameter) do
        local x = point.x - centerX
        local y = point.y - centerY
        local newX = x * math.cos(angle) + y * math.sin(angle)
        local newY = -x * math.sin(angle) + y * math.cos(angle)
        table.insert(newPoints, {x = newX + centerX, y = newY + centerY})
    end
    return newPoints
end

function GetPerpendicularDiameter(radius, x1, y1, x2, y2)
    --возвращает координаты конечных точек диаметра перпендикулярного заданному диаметру
    local midX = (x1 + x2) / 2
    local midY = (y1 + y2) / 2
    local slope = (y2 - y1) / (x2 - x1)
    local perpSlope = -1 / slope
    local x3 = midX + math.sqrt(radius^2 / (1 + perpSlope^2))
    local y3 = perpSlope * (x3 - midX) + midY
    local x4 = midX - math.sqrt(radius^2 / (1 + perpSlope^2))
    local y4 = perpSlope * (x4 - midX) + midY
    return x3, y3, x4, y4
end

function MovePoint(x1, y1, x2, y2, x3, y3)
    --бред
    local angle = CalculateAngleAndDistance(x1, y1, x2, y2)
    local dist = CalculateDistance(x1, y1, x3, y3)
    local newX3 = x1 + dist * math.cos(angle)
    local newY3 = y1 + dist * math.sin(angle)
    return newX3, newY3
end


function GetPointsOnCircle(centerX, centerY, radius, interval)
    --возвращает таблицу точек на окружности
    local points = {}
    local numPoints = math.floor(2 * math.pi / interval)
    --print(numPoints)
    for i = 1, numPoints do
        local angle = interval * (i - 1)
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(points, {x = x, y = y})
    end
    return points
end

function HexagonPoints(centerX, centerY, radius)
    --возвращает вершины шестиугольника
    local points = {}
    for i = 1, 6 do
        local angle = 2 * math.pi / 6 * (i - 1)
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(points, x)
        table.insert(points, y)
    end
    return points
end

function GetHexagonPoints(centerX, centerY, radius, d)
    --возвращает таблицу точек на контуре шестиугольника
    local points = HexagonPoints(centerX, centerY, radius)
    local allPoints = {}
    for i = 1, #points - 2, 2 do
        local x1 = points[i]
        local y1 = points[i + 1]
        local x2 = points[i + 2]
        local y2 = points[i + 3]
        local sidePoints = GetPointsOnLine(x1, y1, x2, y2, d)
        table.remove(sidePoints, #sidePoints)
        for _, point in ipairs(sidePoints) do
            table.insert(allPoints, point)
        end
    end
    local x1 = points[#points - 1]
    local y1 = points[#points]
    local x2 = points[1]
    local y2 = points[2]
    local sidePoints = GetPointsOnLine(x1, y1, x2, y2, d)
    table.remove(sidePoints, #sidePoints)
    for _, point in ipairs(sidePoints) do
        table.insert(allPoints, point)
    end
    return allPoints
end

function IsPointInHexagon(x, y, hexagonPoints)
    --проверяет наличие точки в пространстве, ограниченном контуром шестиугольника
    local intersections = 0
    for i = 1, #hexagonPoints - 1 do
        local x1 = hexagonPoints[i].x
        local y1 = hexagonPoints[i].y
        local x2 = hexagonPoints[i + 1].x
        local y2 = hexagonPoints[i + 1].y
        if ((y1 > y) ~= (y2 > y)) and (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) then
            intersections = intersections + 1
        end
    end
    local x1 = hexagonPoints[#hexagonPoints].x
    local y1 = hexagonPoints[#hexagonPoints].y
    local x2 = hexagonPoints[1].x
    local y2 = hexagonPoints[1].y
    if ((y1 > y) ~= (y2 > y)) and (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) then
        intersections = intersections + 1
    end
    return intersections % 2 == 1
end

function CirclePath(radius, centerX, centerY, angleStep)
    --движение точки по окружности
    local points = {}
    local steps = math.floor(2 * math.pi / angleStep)
    for i = 1, steps do
        local angle = -i * angleStep
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(points, {x = x, y = y})
    end
    return points
end
function PlayExplode(x, y)
    local snd = CreateSound("Sound\\Destructibles\\BarrelExplosion1.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("Sound\\Destructibles\\BarrelExplosion1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStage2()
    PlaySound("Units/Undead/HeroCryptLord/NerubianCryptLordPissed1.flac")
end

function PlayDevouring()
    PlaySound("Units/Undead/Ghoul/Cannibalize.flac")
end

function PlayError()
    PlaySound("Sound/Interface/Error.flac")
end

function PlayCage()
    PlaySound("Buildings/Undead/Graveyard/GraveYardWhat1.flac")
end

function PlayAcid()
    PlaySound("Units/Undead/HeroCryptLord/NerubianCryptLordYesAttack2.flac")
end

function PlayHit()
    PlaySound("sounds\\hit")
end

function PlayScream()
    PlaySound("Units/Undead/Shade/ShadeDeath1")
end

function PlaySawFleshSound()
    PlaySound("sounds\\sawflesh.flac")
end

function PlayDashSound()
    PlaySound("Abilities/Spells/NightElf/Blink/BlinkBirth1.flac")
end

function PlayImpaleSound()
    PlaySound("Abilities/Spells/Undead/Impale/ImpaleHit.flac")
end

function PlayBrokenChain()
    PlaySound("Units/Human/SteamTank/SteamTankAttack1")
end

function PlayChain()
    PlaySound("sounds\\chain.flac")
end

function PlayStoneSound1(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound2(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath2.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSound3(x, y)
    local snd = CreateSound("doodads\\terrain\\rockchunks\\rockchunksdeath3.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 0)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("doodads\\terrain\\rockchunks\\rockchunksdeath1.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayStoneSoundMain(x, y)
    local t = {PlayStoneSound1, PlayStoneSound2, PlayStoneSound3}
    local n = math.random(#t)
    t[n](x, y)
end

function PlayPainSound1()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead04x\\L04Arthas36.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound2()
    local snd = CreateSound("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sound\\dialogue\\undeadexpcamp\\undead07cxInterlude\\L07CArthas43.flac") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound3()
    local snd = CreateSound("sounds\\Pain3",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound4()
    local snd = CreateSound("sounds\\Pain4",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSound5()
    local snd = CreateSound("sounds\\Pain5",false, false, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 19)
    SetSoundDuration( snd, GetSoundFileDuration("sounds\\Pain3") )
    SetSoundVolume( snd, 70)
    StartSound(snd)
    KillSoundWhenDone(snd)
end

function PlayPainSoundMain()
    local foos = {PlayPainSound1, PlayPainSound2, PlayPainSound3, PlayPainSound4, PlayPainSound5}
    local n = math.random(#foos)
    foos[n]()
end

function PlayImpaleMarkerSound(x, y)
    local snd = CreateSound("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac",false, true, false, 10, 10, "DefaultEAXON")
    SetSoundChannel( snd, 10)
    SetSoundDistances( snd, 600.00, 3200 )
    --SetSoundDistanceCutoff( snd, 3000.00)
    SetSoundDuration( snd, GetSoundFileDuration("Abilities\\weapons\\AvengerMissile\\DestroyerMissile.flac") )
    SetSoundVolume( snd, 60)
    --SetSoundConeAngles( snd, 0.0, 0.0, 127 )
    --SetSoundConeOrientation( snd, 0.0, 0.0, 0.0 )
    --SetSoundPitch( snd, 1.0 )
    SetSoundPosition(snd, x, y,100)
    StartSound(snd)
    KillSoundWhenDone(snd)
end


function CreateBarrier()
    local points = GetPointsOnCircle(CenterX, CenterY, Radius, 2 * math.pi / 180)

    for i = 1, #points do
        local angle = CalculateAngle(points[i].x, points[i].y, CenterX, CenterY) + math.pi / 2
        local eff = AddSpecialEffect("models\\barrier", points[i].x, points[i].y)
        BlzSetSpecialEffectScale(eff, 2)
        --BlzSetSpecialEffectZ(eff, 300)
        BlzSetSpecialEffectYaw(eff, angle)
        BlzSetSpecialEffectColorByPlayer(eff, Player(6))
        --BlzSetSpecialEffectScale(eff, 2)
        --BlzSetSpecialEffectZ(eff, 400)
        table.insert(barrier, eff)
    end
    CreateStatues()
end

function LockBarrier()
    local points = GetPointsOnCircle(CenterX, CenterY, Radius, 2 * math.pi / 180)
    local points = GetPointsOnCircle(CenterX, CenterY, Radius, 1 * math.pi / 180)
    for i = 1, #barrier do
        BlzSetSpecialEffectColorByPlayer(barrier[i], Player(0))
    end

    for p = 1, #points do
        CreateDestructable(_('YTfb'), points[p].x, points[p].y, GetRandomDirectionDeg(), 1, 0 )
    end
end


function AttackTimer()
    --эти атаки не могут быть одновременно друг с другом: {глыбы, файрболлы, крест жуков}, {крест жуков, импейл}
    --
    math.randomseed(os.time())
    globalAttackTimer = CreateTimer()
    TimerStart(globalAttackTimer, 6, true, function()
        if Stage == 1 then
            InvulnerableBlock(0.75)
            if not castFireballs and not castBeetles and not castCorpse and not castRocks then
                local rand = math.random()
                if rand <= 0.25 then
                    local fireTimer = CreateTimer()
                    local fireCounter = 0
                    castFireballs = true
                    TimerStart(fireTimer, 1.25, true, function()
                        FireBalls(0.1, 15, 20)
                        fireCounter = fireCounter + 1
                        if fireCounter > 6 then
                            castFireballs = false
                            DestroyTimer(fireTimer)
                        end
                    end)
                elseif rand <= 0.5 then
                    castRocks = true
                    ThrowStones(10)
                elseif rand <= 0.75 then
                    local beetleTimer = CreateTimer()
                    local beetleCounter = 0
                    castBeetles = true
                    TimerStart(beetleTimer, 1.2, true, function()
                        BeetleLaunch()
                        beetleCounter = beetleCounter + 1
                        if beetleCounter > 10 then
                            castBeetles = false
                            DestroyTimer(beetleTimer)
                        end
                    end)
                else
                    castCorpse = true
                    CorpseBombs(10, 1.5)
                end
            end
            local rand2 = math.random()
            if rand2 <= 0.2 then
                TripleImpale(math.random(30, 35))
            elseif rand2 <= 0.35 and not CageOn and not sawing then
                Cage(500, 15)
                local cageTimer = CreateTimer()
                TimerStart(cageTimer, 5, false, function()
                    if SlayerInsideCage then
                        FireBalls(0.25, 1, 30)
                    end
                    DestroyTimer(cageTimer)
                end)
            elseif rand2 <= 0.55 and not acidGlobal then
                Acid(12, 30)
            end
        end

        if Stage == 2 then
            InvulnerableBlock(0.65)
            if not castFireballs and not castBeetles and not castCorpse and not castRocks then
                local rand = math.random()
                if rand <= 0.25 then
                    local fireTimer = CreateTimer()
                    local fireCounter = 0
                    castFireballs = true
                    TimerStart(fireTimer, 1.1, true, function()
                        FireBalls(0.1, 15, 20)
                        fireCounter = fireCounter + 1
                        if fireCounter > 5 then
                            castFireballs = false
                            DestroyTimer(fireTimer)
                        end
                    end)
                elseif rand <= 0.5 then
                    castRocks = true
                    ThrowStones(10)
                elseif rand <= 0.75 then
                    local beetleTimer = CreateTimer()
                    local beetleCounter = 0
                    castBeetles = true
                    TimerStart(beetleTimer, 1.1, true, function()
                        BeetleLaunch()
                        beetleCounter = beetleCounter + 1
                        if beetleCounter > 10 then
                            castBeetles = false
                            DestroyTimer(beetleTimer)
                        end
                    end)
                else
                    castCorpse = true
                    CorpseBombs(11, 1.25)
                end
            end
            local rand2 = math.random()
            if rand2 <= 0.25 then
                TripleImpale(math.random(30, 35))
            elseif rand2 <= 0.4 and not CageOn and not sawing then
                Cage(500, 15)
                local cageTimer = CreateTimer()
                TimerStart(cageTimer, 5, false, function()
                    if SlayerInsideCage then
                        FireBalls(0.25, 1, 30)
                    end
                    DestroyTimer(cageTimer)
                end)
            elseif rand2 <= 0.6 and not acidGlobal then
                Acid(18, 30)
            elseif rand2 <= 0.66 and not castCarousel and not SlayerInsideCage then
                Bugs()
            end
        end
    end)
end


function InvulnerableBlock(chance)
    local rand = math.random()
    if rand <= chance then
        Invulnerable(false)
        local t = CreateTimer()
        local dur = math.random(2, 5)
        TimerStart(t, dur, false, function()
            Invulnerable(true)
            DestroyTimer(t)
        end)
    end
end
function InitCreepsMovement()
    for i = 1, #creeps do
        local xy = RandomPointInCircle(CenterX, CenterY, Radius)
        IssuePointOrder(creeps[i], "move",xy[1], xy[2])
    end
    local t = CreateTimer()
    TimerStart(t, 10, true, function()
        for i = 1, #creeps do
            local xy = RandomPointInCircle(CenterX, CenterY, Radius)
            IssuePointOrder(creeps[i], "move",xy[1], xy[2])
        end
    end)
end
function GotDamage(type)
    if not BlzIsUnitInvulnerable(slayer) then
        --print("got damage")
        PlayPainSoundMain()

        if type == "mechanical" then
            slayerHP = slayerHP - 7
            CrackedGlassEffect()
        end

        if type == "impale" then
            slayerHP = slayerHP - 20
            CrackedGlassEffect()
        end

        if type == "fire" then
            slayerHP = slayerHP - 5
            MaskEffect("backdrops\\VignetteFire.dds", 100, 100, 100)
        end

        if type == "acid" then
            slayerHP = slayerHP - 2
            MaskEffect("backdrops\\VignettePoison.dds", 100, 100, 100)
        end

        if type == "bite" then
            slayerHP = slayerHP - 2
            MaskEffect("backdrops\\VignetteDamage.dds", 75, 10, 10)
            PlayDevouring()
        end

        if type == "blood" then
            slayerHP = slayerHP - 4
            --print("blood")
            CameraSetEQNoiseForPlayer( Player(0), 30.00 )
            local t = CreateTimer()
            TimerStart(t, 0.2, false, function()
                CameraClearNoiseForPlayer( Player(0) )
                DestroyTimer(t)
            end)
            BloodFrame()

            --MaskEffect("backdrops\\blood1.dds", 100, 100, 100)
        end
        BlzFrameSetValue(bar2, slayerHP)
        if slayerHP < 50 then
            if not lowHealh then
                lowHealh = true
                DisplayWarningHealth()
            end
            if slayerHP < 0 then
                Lost()
            end
        end
    end
    SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
end

function Lost()
    KillUnit(slayer)
    BlzDestroyFrame(bar2)
    TimerStart(CreateTimer(), 5, false, function()
        CustomDefeatBJ(GetLocalPlayer(), "You got no chance in Hell!")
    end)
end

function BloodFrame()

    local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
    BlzFrameSetLevel(Mask,4)
    BlzFrameSetAbsPoint(Mask, FRAMEPOINT_TOPLEFT, -0.1338, 0.6)
    BlzFrameSetAbsPoint(Mask, FRAMEPOINT_BOTTOMRIGHT, 0.936020, 0)
    BlzFrameSetTexture(Mask, "backdrops\\blood1.dds", 0, true)
    BlzFrameSetAlpha(Mask, 255)
    local alpha = 255
    TimerStart(CreateTimer(), 1/32, true, function()
        alpha = alpha - 4
        if alpha <=0 then
            BlzFrameSetAlpha(Mask, 0)
            BlzDestroyFrame(Mask)
            DestroyTimer(GetExpiredTimer())
        else
            BlzFrameSetAlpha(Mask, alpha)
        end
    end)
end

function Win()
    KillUnit(boss)
    DestroyTimer(globalAttackTimer)
    BlzDestroyFrame(invul)
    BlzDestroyFrame(bar)
    TimerStart(CreateTimer(), 5, false, function()
        CustomVictoryBJ(GetLocalPlayer(), "You are the true Scourge Slayer!", false)
    end)
end

function BloodFrameOLD()
    local randomX = math.random(10, 70) / 100
    local randomY = math.random(20, 50) / 100
    local randomS = math.random(20, 50) / 100
    local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
    BlzFrameSetLevel(Mask,4)
    BlzFrameSetAbsPoint(Mask, FRAMEPOINT_CENTER, randomX, randomY)
    BlzFrameSetSize(Mask, randomS, randomS)
    BlzFrameSetTexture(Mask, "backdrops\\blood5", 0, true)
    BlzFrameSetAlpha(Mask, 255)
    local alpha = 255
    TimerStart(CreateTimer(), 1/32, true, function()
        alpha = alpha - 4
        if alpha <=0 then
            BlzFrameSetAlpha(Mask, 0)
            BlzDestroyFrame(Mask)
            DestroyTimer(GetExpiredTimer())
        else
            BlzFrameSetAlpha(Mask, alpha)
        end
    end)
end

function MaskEffect(path, red, green, blue)
    DisplayCineFilter(false)
    CinematicFilterGenericBJ( 5.00, BLEND_MODE_BLEND, path, red, green, blue, 0.00, 0, 0, 0, 100.00 )
end

function CrackedGlassEffect()
    CameraSetEQNoiseForPlayer( Player(0), 30.00 )
    local t = CreateTimer()
    TimerStart(t, 0.2, false, function()
        CameraClearNoiseForPlayer( Player(0) )
        DestroyTimer(t)
    end)

    local randx = math.random() * 0.9
    local randy = math.random() * 0.5
    local randAnim = math.random(0, 4)
    local randScale = math.random() * 1.25 + 0.75

    ----------
    local crack = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0), "", 0)
    --
    BlzFrameSetAbsPoint(crack, FRAMEPOINT_CENTER, randx, randy)
    BlzFrameSetLevel(crack, 4)
    BlzFrameSetSize(crack, 0.01, 0.01)
    BlzFrameSetModel(crack, "sprites\\brokenglass", 1)
    BlzFrameSetScale(crack, randScale)
    BlzFrameSetSpriteAnimate(crack, randAnim, 2)
    BlzFrameSetAlpha(crack, 255)
    PlayHit()

    local t2 = CreateTimer()
    local alpha = 255
    TimerStart(t2, 1/16, true, function()
        alpha = alpha - 1
        if alpha <= 0 then
            BlzFrameSetAlpha(crack, 0)
            BlzDestroyFrame(crack)
            DestroyTimer(t)
        else
            BlzFrameSetAlpha(crack, alpha)
        end
    end)
end

function ControlBossDamage()
    if not BlzIsUnitInvulnerable(boss) then
        bossHP = bossHP - 1
        if bossHP <= 0 then
            Win()
        end
        BlzFrameSetValue(bar, bossHP)
        if bossHP <= (bossHPConst - bossHPConst/5) and Stage == 1 then
            Stage = 2
            PlayStage2()
            local text = "|cffff0000Second stage!\n\nThere is no more safe zone for you|r"
            local descr = CreateText(consoleFrame, 0.4, 0.4, 0.4, text, 2)
            BlzFrameSetScale(descr, 4)
            local alpha = 255

            TimerStart(CreateTimer(), 1/32, true, function()
                alpha = alpha - 1
                if alpha <=0 then
                    BlzFrameSetAlpha(descr, 0)
                    BlzDestroyFrame(descr)
                    DestroyTimer(GetExpiredTimer())
                else
                    BlzFrameSetAlpha(descr, alpha)
                end
            end)

            if IsPointInCircle(GetUnitX(slayer), GetUnitY(slayer), CenterX, CenterY, Radius) then
                LockBarrier()
            else
                TimerStart(CreateTimer(), 1/2, true, function()
                    if IsPointInCircle(GetUnitX(slayer), GetUnitY(slayer), CenterX, CenterY, Radius) then
                        LockBarrier()
                        DestroyTimer(GetExpiredTimer())
                    end
                end)
            end
        end
    end
end

function CheckBugsDamage(x, y)
    if IsPointInCircle(GetUnitX(slayer), GetUnitY(slayer), x, y, 100) then
        carouselCounter = carouselCounter + 1
        if carouselCounter ~= 0 and carouselCounter % 3 == 0 then
            GotDamage("bite")
        end
    end


end

function ControlDmg(unit)
    SetUnitState(unit, UNIT_STATE_LIFE, GetUnitState(unit, UNIT_STATE_LIFE) - 25)
    if GetUnitState(unit, UNIT_STATE_LIFE) < 1 then
        for i, v in ipairs(creeps) do
            if v == unit then
                table.remove(creeps, i)
                break
            end
        end
        for i, v in ipairs(chainTargets) do
            if v == unit then
                table.remove(chainTargets, i)
                break
            end
        end
        AddCreep()
    end
end

function CheckFireballDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 50) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("fire")
    end
    return
end

function CheckCorpseBombDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 95) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("mechanical")
    end
    return
end

function CheckCorpseFireworksDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 40, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("blood")
    end
    return
end


function CheckStoneDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 32, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("mechanical")
        return true
    else
        return false
    end
end

function CheckBeetleDamage(x, y)
    if IsCirclesIntersect(GetUnitX(slayer), GetUnitY(slayer), 32, x, y, 60) and not BlzIsUnitInvulnerable(slayer) then
        GotDamage("bite")
        return true
    else
        return false
    end
end

function BeetlePeriodic()
    local t = CreateTimer()
    TimerStart(t, 0.5, true, function()
        if beetleAtached then
            GotDamage("bite")
        else
            DestroyTimer(t)
        end
        --print(beetleAtached)
    end)
end

function InitDamageTrigger()
    local DamageTrigger = CreateTrigger()
    --TriggerRegisterUnitEvent(DamageTrigger, impaleCasters[1], EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    TriggerRegisterPlayerUnitEvent(DamageTrigger, Player(2), EVENT_PLAYER_UNIT_SPELL_ENDCAST, null)
    TriggerAddCondition(DamageTrigger, Condition(ResetAfterDamage))

end

function ResetAfterDamage()
    SetUnitLookAt( slayer, "bone_turret", posdummy, 0, 0, 0 )
    SetUnitState(slayer, UNIT_STATE_LIFE, GetUnitState(slayer, UNIT_STATE_MAX_LIFE))
    --GotDamage()
    if GetTriggerUnit() == impaleCasters[1] and (GetUnitAbilityLevel(slayer, _('BUim')) > 0) then
        GotDamage("impale")
    end
end




function StatusList()
    CenterX = 1
    CenterY = 1
    Radius = 1800
    barrier = {} -- таблица эффектов
    -----------
    slayerHP = 180
    slayerHPConst = 180
    Stage = 1 --текущая стадия
    safetyZone = false --герой ввышел из поля битвы
    ------
    bossHP = 300
    bossHPConst = 300
    lowHealh = false
    -----
    creeps = {} --таблица крипов
    maxcreeps = 8


    iconsUI = {} --иконки
    chargesUI = {} --заряды
    cooldownUI = {} --кулдауны
    ------
    CageOn = false --существует ли клетка на карте
    SlayerInsideCage = false --герой в клетке
    hexPoints = {} --координаты клетки

    castFireballs = false --кастует файрболлы
    castRocks = false --кастует глыбы
    castCarousel = false --кастует карусель жуков
    carouselCounter = 0 --считает урон от карусели
    castCorpse = false --кастует трупы
    castBeetles = false --бросает жуков

    ------
    cooldown = false --кулдаун ракетницы
    rocketCharges = 125 --заряды ракетницы
    rocketChargesConst = 125
    lowAmmo = false --индикатор малого количества заряда ракетницы

    Chaining = false --юзает хук
    chaincooldown = false --кулдаун хука
    chainCharges = 3 --заряды хука
    chainChargesConst = 3
    chainCooldown = 0 --кулдаун хука
    chainCooldownConst = 10
    chainTargets = {} --возможные таргеты для хука
    slayerEffects = {} --таблица с эффектами для поиска цели хука
    slayerEffectsRed = {}
    targetEffects = {}

    acidGlobal = false --кислота на карте
    puddles = {} --координаты луж кислоты
    puddlesEffects = {} --таблица эффектов с кислотой

    beetleAtached = false --жук прицепился к герою
    beetleAttach = nil --глоаблка для хранения эффекта жука
    beetleHP = 3 --хп прицепившегося жука
    beetleFrame = nil --глобалка для фрейма с жуком

    sawing = false --герой пилит
    sawingCharges = 3 --заряды пилы
    sawingChargesConst = 3
    sawingDefaultReward = 60
    sawingDelay = 1 --ограничение на юз пилы подряд
    fuelOnMap = false --есть заспавненное топливо
    fuel = {} --таблица заспавненного топлива

    dashing = false --герой в рывке
    dashCharges = 4 --заряды рывка
    dashChargesConst = 4
    dashCooldown = 0 --кулдаун зарядя
    dashCooldownConst = 5.0
    chargesOnMap = false --есть заряды на карте
    dashChargesItems = {} --таблица заспавненных зарядов
    -------
    cdTimer = nil --глобалка для таймера, обновляющего кулдауны
    cooldownUpdating = false --показывает, что работает таймер, обновляющий кулдауны
    ----------


end
RealGetUnitX = GetUnitX
RealGetUnitY = GetUnitY


function GetUnitRealX(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitX(unit) - 16. end
    end

    return RealGetUnitX(unit)
end

function GetUnitRealY(unit)
    local collision = math.floor(BlzGetUnitCollisionSize(unit) + 0.5)

    if not IsUnitType(unit, UNIT_TYPE_STRUCTURE) then
        if (collision < 32 and collision > 15) or collision > 47 then return RealGetUnitY(unit) - 16. end
    end

    return RealGetUnitY(unit)
end
function CreateBlood()
    for i = 1, math.random(10, 20) do
        local xy = RandomPointInCircle(CenterX, CenterY, Radius)
        local eff = AddSpecialEffect("blood", xy[1], xy[2])
        local angle = math.random() * 2 * math.pi
        BlzSetSpecialEffectYaw(eff, angle)
    end
end


function CreateStatues()
    local points = GetPointsOnCircle(CenterX, CenterY, Radius-140, 36 * math.pi / 180)

    for i = 1, #points do
        local angle = CalculateAngle(points[i].x, points[i].y, CenterX, CenterY) + math.pi / 4
        local eff = AddSpecialEffect("models\\SpiderStatue", points[i].x, points[i].y)
        BlzSetSpecialEffectYaw(eff, angle)
        CreateFakeColumn(points[i].x, points[i].y)
    end
end

function CreateBones()
    for i = 1, math.random(8, 14) do
        local xy = RandomPointInCircle(CenterX, CenterY, Radius)
        local n = math.random(0, 4)
        local angle = math.random() * 2 * math.pi
        local eff = AddSpecialEffect("environment\\foliage\\blight\\bones\\foliage_blight_bone_0"..n, xy[1], xy[2])
        BlzSetSpecialEffectYaw(eff, angle)
    end
end
function BossFight(frame)
    PlayMusic( "sounds\\bfg_division" )
    local length = GetSoundFileDuration("sounds\\bfg_division")
    local musicTimer = CreateTimer()
    TimerStart(musicTimer, length, false, function()
        ClearMapMusicBJ()
        PlayMusic("sounds\\fear.flac;sounds\\bfg_division.flac")
        DestroyTimer(musicTimer)
    end)


    local t = CreateTimer()
    TimerStart(t, 14, false, function()
        CinematicFilterGenericBJ( 1, BLEND_MODE_BLEND, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 100, 100, 100, 0.00, 0, 0, 0, 100 )
        SetTimeOfDay( 18 )
        InitControlMouse()
        InitControlKeys()

        InitDamageTrigger()
        AttackTimer()
        InitCreepsMovement()
        BlzDestroyFrame(frame)
        local t1 = CreateTimer()
        TimerStart(t1, 2, false, function()
            TripleImpale(30)
            DestroyTimer(t1)
        end)

    end)

end
function HPBar()
    consoleFrame = BlzGetFrameByName("ConsoleUIBackdrop", 0)
    bar = BlzCreateFrameByType("STATUSBAR", "", consoleFrame, "", 0)

    BlzFrameSetAbsPoint(bar, FRAMEPOINT_CENTER, 0.4, 0.57)
    -- Screen Size does not matter but has to be there
    BlzFrameSetSize(bar, 0.00001, 0.00001)

    -- Models don't care about Frame Size, But world Object Models are huge . To use them in the UI one has to scale them down alot.
    BlzFrameSetScale(bar, 1)

    --BlzFrameSetModel(bar, "ui/feedback/cooldown/ui-cooldown-indicator.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/XpBar/XpBarConsole.mdx", 0)
    BlzFrameSetModel(bar, "sprites/testbar.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/buildprogressbar/buildprogressbar.mdx", 0)
    BlzFrameSetMinMaxValue(bar, 0, bossHPConst+1)
    BlzFrameSetValue(bar, bossHPConst)
    local i = 0
    TimerStart(CreateTimer(), 4, false, function()
        --BlzFrameSetModel(bar, "sprites/testbar1.mdx", 0)
        --BlzFrameSetValue(bar, i)
        --i = i + 1
        --if i > 100 then
            --i = 0
        --end
        --i = GetRandomInt(0, 100)
        --print(BlzFrameGetValue(bar))
    end)

    invul = BlzCreateFrameByType("BACKDROP", "", bar, "", 1)

    BlzFrameSetAbsPoint(invul, FRAMEPOINT_CENTER, 0.4, 0.58)
    BlzFrameSetSize(invul, 0.34, 0.17)
    BlzFrameSetTexture(invul, "backdrops\\invul", 0, true)
    BlzFrameSetVisible(invul, true)
    ------------

    bar2 = BlzCreateFrameByType("STATUSBAR", "", BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0), "", 0)
    BlzFrameSetAbsPoint(bar2, FRAMEPOINT_CENTER, 0.4, 0.03)
    -- Screen Size does not matter but has to be there
    BlzFrameSetSize(bar2, 0.00001, 0.00001)

    -- Models don't care about Frame Size, But world Object Models are huge . To use them in the UI one has to scale them down alot.
    BlzFrameSetScale(bar2, 1)

    --BlzFrameSetModel(bar, "ui/feedback/cooldown/ui-cooldown-indicator.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/XpBar/XpBarConsole.mdx", 0)
    BlzFrameSetModel(bar2, "sprites/testbar2.mdx", 0)
    --BlzFrameSetModel(bar, "ui/feedback/buildprogressbar/buildprogressbar.mdx", 0)
    BlzFrameSetMinMaxValue(bar2, 1, slayerHPConst+1)
    BlzFrameSetValue(bar2, slayerHPConst)
end
function Icons()
    local textures = {
        "backdrops\\rocketIcon",
        "backdrops\\dashIcon",
        "backdrops\\sawIcon",
        "backdrops\\chainIcon"
    }
    local x = -0.095
    local y = 0.5

    local offsety = 0.1
    local size = 0.08

    local size2 = 0.05
    local size3 = 0.065

    consoleFrame = BlzGetFrameByName("ConsoleUIBackdrop", 0)
    for i = 1, 4 do
        local yy = y - offsety * (i-1)
        local charges = CreateBackdrop(consoleFrame, x+0.035, yy-0.035, size2, "backdrops\\octFrame1", 6)
        local icon = CreateBackdrop(charges, x, yy, size, textures[i], 6)
        table.insert(iconsUI, icon)
        --table.insert(iconsUI, icon)
        if i % 2 == 0 then
            local cooldownFrame = CreateBackdrop(charges, x+0.035+0.0325, yy-0.003, size3, "backdrops\\octFrame1", 6)
            local cooldownText = CreateText(cooldownFrame, x+0.035+0.032, yy-0.0027, size3, 0, 6)
            table.insert(cooldownUI, cooldownText)
        end
        local chargesText = CreateText(charges, x+0.0345, yy-0.034, size2, "100", 6)
        table.insert(chargesUI, chargesText)

        BlzFrameSetText(chargesUI[1], rocketCharges)
        BlzFrameSetText(chargesUI[2], dashCharges)
        BlzFrameSetText(chargesUI[3], sawingCharges)
        BlzFrameSetText(chargesUI[4], chainCharges)
    end
end

function UpdateCharges(type, value)
    BlzFrameSetText(chargesUI[type], value)
end

function DisplayCooldown(start)
    if dashCooldown == 0 and dashCharges < dashChargesConst then
        dashCooldown = dashCooldownConst
    end
    if chainCooldown == 0 and chainCharges < chainChargesConst then
        chainCooldown =  chainCooldownConst
    end
    --print(cooldownUpdating)
    if start and not cooldownUpdating then
        cdTimer = CreateTimer()
        cooldownUpdating = true
        TimerStart(cdTimer, 0.01, true, function()
            if dashCooldown > 0 and dashCooldown <= dashCooldownConst and dashCharges < dashChargesConst then
                dashCooldown = dashCooldown - 0.01
                BlzFrameSetText(cooldownUI[1], string.format("%.2f", dashCooldown))
            elseif dashCooldown <= 0 then
                BlzFrameSetText(cooldownUI[1], 0)
                if dashCharges < dashChargesConst then
                    dashCharges = dashCharges + 1
                    SetIconEnable(iconsUI[2], true)
                    UpdateCharges(2, dashCharges)
                    if dashCharges == dashChargesConst then
                        dashCooldown = 0
                        if chainCooldown == 0 then
                            cooldownUpdating = false
                            DestroyTimer(cdTimer)
                        end
                    else
                        dashCooldown = dashCooldownConst
                    end
                end
            end

            if chainCooldown > 0 and chainCooldown <= chainCooldownConst and chainCharges < chainChargesConst then
                chainCooldown = chainCooldown - 0.01
                BlzFrameSetText(cooldownUI[2], string.format("%.2f", chainCooldown))
            elseif chainCooldown <= 0 then
                BlzFrameSetText(cooldownUI[2], 0)
                if chainCharges < chainChargesConst then
                    chainCharges = chainCharges + 1
                    SetIconEnable(iconsUI[4], true)
                    UpdateCharges(4, chainCharges)
                    if chainCharges == chainChargesConst then
                        chainCooldown = 0
                        if dashCooldown == 0 then
                            cooldownUpdating = false
                            DestroyTimer(cdTimer)
                        end
                    else
                        chainCooldown = chainCooldownConst
                    end
                end
            end
        end)
    end
end

function SetIconEnable(frame, flag)
    if flag then
        BlzFrameSetAlpha(frame, 255)
    else
        BlzFrameSetAlpha(frame, 128)
    end
end


function InitCustomUI()
    HideDefaultUI()
    BlzFrameSetVisible(BlzGetFrameByName("UpperButtonBarFrame",0), true)
    BlzFrameSetVisible(BlzGetFrameByName("UpperButtonBarAlliesButton",0), false)
    BlzFrameSetVisible(BlzGetFrameByName("UpperButtonBarChatButton",0), false)
    BlzFrameSetVisible(BlzGetFrameByName("UpperButtonBarQuestsButton",0), false)

    BlzFrameClearAllPoints(BlzGetFrameByName("UpperButtonBarFrame",0))
    BlzFrameSetScale(BlzGetFrameByName("UpperButtonBarFrame",0), 1.5)
    BlzFrameSetAbsPoint(BlzGetFrameByName("UpperButtonBarFrame",0), FRAMEPOINT_TOPLEFT, -0.26065, 0.6)
    BlzFrameSetAbsPoint(BlzGetFrameByName("UpperButtonBarFrame",0), FRAMEPOINT_BOTTOMRIGHT, -0.16065, 0.56)
    ClickBlocker = BlzCreateFrameByType("TEXT", "name", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
        CreateTextFrame(ClickBlocker, -0.1338, 0.6, 0.936020, 0, 0, "", 1)
            BlzFrameSetEnable(ClickBlocker, true)
    HPBar()
    Icons()
    CreateWarnings()
end
function Safety()
    local fr = BlzCreateFrameByType("BACKDROP", "", consoleFrame, "", 1)
    BlzFrameSetLevel(fr, 2)
    BlzFrameSetAbsPoint(fr, FRAMEPOINT_CENTER, 0.4, 0.5)
    BlzFrameSetSize(fr, 0.34, 0.17)
    BlzFrameSetTexture(fr, "backdrops\\safety", 0, true)
    BlzFrameSetVisible(fr, true)

    local alpha = 255
    TimerStart(CreateTimer(), 1/32, true, function()
        alpha = alpha - 4
        if alpha <=0 then
            BlzFrameSetAlpha(fr, 0)
            BlzDestroyFrame(fr)
            DestroyTimer(GetExpiredTimer())
        else
            BlzFrameSetAlpha(fr, alpha)
        end
    end)
end
function InitCameraScrollBar()
    -- create a vertical slider by inheriting from a Scrollbar. It will use esc menu textures
    local sliderFrame = BlzCreateFrameByType( "SLIDER", "TestSlider", BlzGetFrameByName("ConsoleUIBackdrop", 0), "QuestMainListScrollBar", 0 )
    -- clear the inherited attachment
    BlzFrameClearAllPoints(sliderFrame)
    -- set pos and size
    BlzFrameSetLevel(sliderFrame, 3)
    BlzFrameSetAbsPoint(sliderFrame, FRAMEPOINT_CENTER, 0.92, 0.30 )
    BlzFrameSetSize(sliderFrame, 0.014, 0.1 )
    -- define the area the user can choose from
    BlzFrameSetMinMaxValue(sliderFrame, 0, 80)
    -- how accurate the user can choose value
    BlzFrameSetStepSize(sliderFrame, 20)
    BlzFrameSetValue(sliderFrame, 40)

    local trigger = CreateTrigger()

    -- register the Slider Event
    BlzTriggerRegisterFrameEvent(trigger, sliderFrame, FRAMEEVENT_SLIDER_VALUE_CHANGED)

    -- this happens when the Slider is pushed
    TriggerAddAction(trigger, function()
        local frame = BlzGetTriggerFrame()
        --print(BlzFrameGetName(frame), "new Value", BlzGetTriggerFrameValue())
        SetGameCamera(BlzGetTriggerFrameValue())

    end)

    -- scorllable with mousewheel
    local triggerWheel = CreateTrigger()
    -- register the Mouse Wheel Event for the Slider
    BlzTriggerRegisterFrameEvent(triggerWheel, sliderFrame, FRAMEEVENT_MOUSE_WHEEL)
    -- this happens when the Mouse wheel is rolled while it points at the slider
    TriggerAddAction(triggerWheel, function()

        -- BlzGetTriggerFrameValue() tells us in which direction the wheel was rolled
        local add
        if BlzGetTriggerFrameValue() > 0 then
            add = 20
        else
            add = -20
        end

        -- the scrolling should only affect the triggering Player
        if GetLocalPlayer() == GetTriggerPlayer() then
            BlzFrameSetValue(sliderFrame, BlzFrameGetValue(sliderFrame) + add)
        end
    end)
end
function CreateWarnings()
    ammoFr = CreateBackdropTwoPoints(consoleFrame, 0, 0.5, 0.2, 0.42, "backdrops\\lowammo", 7)
    BlzFrameSetSize(ammoFr, 0.2, 0.08)
    BlzFrameClearAllPoints(ammoFr)
    BlzFrameSetVisible(ammoFr, false)
    healthFr = CreateBackdropTwoPoints(consoleFrame, 0.2, 0.15, 0.4, 0.07, "backdrops\\lowhealth", 7)
    BlzFrameSetSize(healthFr, 0.2, 0.08)
    BlzFrameClearAllPoints(healthFr)
    BlzFrameSetVisible(healthFr, false)

    ammoPoints = CirclePath(0.01, 0.1, 0.5, 9*math.pi / 180)
    healthPoints = CirclePath(0.01, 0.3, 0.11, 9*math.pi / 180)
end

function DisplayWarningAmmo()
    local i = 1
    local sharp = #ammoPoints
    local t = CreateTimer()
    BlzFrameSetVisible(ammoFr, true)

    TimerStart(t, 1/32, true, function()
        if lowAmmo then
            BlzFrameSetAbsPoint(ammoFr, FRAMEPOINT_CENTER, ammoPoints[i].x, ammoPoints[i].y)
            i = i + 1
            if i > sharp then
                i = 1
            end
        else
            BlzFrameSetVisible(ammoFr, false)
            DestroyTimer(t)
        end
    end)
end

function DisplayWarningHealth()
    local i = 1
    local sharp = #healthPoints
    local t = CreateTimer()

    BlzFrameSetVisible(healthFr, true)
    TimerStart(t, 1/32, true, function()
        if lowHealh then
            BlzFrameSetAbsPoint(healthFr, FRAMEPOINT_CENTER, healthPoints[i].x, healthPoints[i].y)
            i = i + 1
            if i > sharp then
                i = 1
            end
        else
            BlzFrameSetVisible(healthFr, false)
            DestroyTimer(t)
        end
    end)
end


function CreateTestUnit()
    local xy = RandomPointInCircle(CenterX, CenterY, Radius)
    local testUnit = CreateUnit(Player(1), _('uaco'), xy[1], xy[2], bj_UNIT_FACING)
    SetUnitPathing(testUnit, false)
    SetUnitMoveSpeed(testUnit, 75)
    SetUnitInvulnerable(testUnit, true)
    SetUnitColor(testUnit, PLAYER_COLOR_SNOW)
    table.insert(creeps, testUnit)
    table.insert(chainTargets, testUnit)
end

function AddCreep()
    if #creeps < maxcreeps then
        local t = CreateTimer()
        local delay = math.random(5, 15)
        TimerStart(t, delay, false, function()
            CreateTestUnit()
        end)
    end
end

function CreateFakeColumn(x, y)
    local testUnit = CreateUnit(Player(1), _('fake'), x, y, bj_UNIT_FACING)
    SetUnitPathing(testUnit, false)
    SetUnitInvulnerable(testUnit, true)
    table.insert(chainTargets, testUnit)
end

function CreateDummy()
    local d = CreateUnit(Player(2), _('Dmmy'), -1500, -1500, bj_UNIT_FACING)
    SetHeroLevel(d, 10, false)
    SelectHeroSkill(d, _('AUim'))
    SetUnitInvulnerable(d, true)
    return d
end
function Acid(numb, duration)
    local points = {}
    for i = 1, numb do
        table.insert(points, RandomPointInCircle(CenterX, CenterY, Radius))
    end

    --local acid = AddSpecialEffect("models\\puddle", 400, 400)
    --BlzSetSpecialEffectScale(acid, 1.5)
    local startX, startY = GetUnitPosition(boss)
    local t = CreateTimer()
    local a = 1
    SetUnitAnimationByIndex(boss, 7)
    TimerStart(t, 1/32, true, function()
        AcidBomb(startX, startY, points[a][1], points[a][2])
        a=a+1
        if a > #points then
            PauseTimer(t)
            DestroyTimer(t)
        end
    end)

    ------------------

    local timerEnd = CreateTimer()
    local timerAlpha = CreateTimer()
    local alpha = 255
    TimerStart(timerEnd, duration, false, function()
        PlayAcid()
        TimerStart(timerAlpha, 1/32, true, function()
            alpha = alpha - 2
            if alpha <= 0 then
                acidGlobal = false
                for ee = 1, #puddlesEffects do
                    BlzSetSpecialEffectAlpha(puddlesEffects[ee], 0)
                    DestroyEffect(puddlesEffects[ee])
                    puddlesEffects[ee] = nil
                    DestroyTimer(timerAlpha)
                end
                puddles = {}
                puddlesEffects = {}
            else
                for e = 1, #puddles do
                    BlzSetSpecialEffectAlpha(puddlesEffects[e], alpha)
                end
            end
            DestroyTimer(timerEnd)
        end)
    end)
end

function AcidBomb(startX, startY, endX, endY)
    if IsPointInCircle(endX, endY, CenterX, CenterY, Radius) then
        --SetUnitFacing(boss, angle*180 / math.pi)
        local maxZ = 820
        local startZ = 400
        local endZ = 220

        local points = ComputePath(startX, startY, startZ, endX, endY, endZ, maxZ, 30)
        local eff = AddSpecialEffect("Abilities\\Spells\\Other\\AcidBomb\\BottleMissile", startX, startY)
        --BlzSetSpecialEffectScale(eff, 1.5)
        local t = CreateTimer()
        local i = 1
        local sharp = #points

        TimerStart(t, 1/32, true, function()
            BlzSetSpecialEffectX(eff, points[i].x)
            BlzSetSpecialEffectY(eff, points[i].y)
            BlzSetSpecialEffectZ(eff, points[i].z)
            i = i + 1
            if i > sharp then
                PauseTimer(t)
                DestroyEffect(eff)

                local acid = AddSpecialEffect("models\\puddle2", points[i-2].x, points[i-2].y)
                BlzSetSpecialEffectYaw(acid, math.random() * 2 * math.pi)
                table.insert(puddles, {x = points[i-2].x, y = points[i-2].y})
                table.insert(puddlesEffects, acid)
                acidGlobal = true
                DestroyTimer(t)
            end
        end)
    end
end
function BeetleLaunch()
    local maxZ = 820
    local startZ = 400
    local endZ = 330
    local x, y = GetUnitPosition(slayer)
    if IsPointInCircle(x, y, CenterX, CenterY, Radius) then
        local startX, startY = GetUnitPosition(boss)
        local eff = AddSpecialEffect("Units\\Undead\\ScarabLvl3\\ScarabLvl3", startX, startY)
        BlzPlaySpecialEffect(eff, ANIM_TYPE_WALK)
        BlzSetSpecialEffectScale(eff, 1.5)
        local angle = CalculateAngle(startX, startY, x, y)
        BlzSetSpecialEffectYaw(eff, angle)
        local points = ComputePath(startX, startY, startZ, x, y, endZ, maxZ, 30)

        local i = 1
        local sharp = #points
        local t = CreateTimer()

        TimerStart(t, 1/32, true, function()
            p = points[i]
            BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
            local xx, yy = GetUnitPosition(slayer)
            local angle = CalculateAngle(p.x, p.y, xx, yy)
            BlzSetSpecialEffectYaw(eff, angle)
            i = i + 1
            if i > sharp then
                PauseTimer(t)
                BeetleCharge(eff, p.x, p.y, p.z)
                DestroyTimer(t)
            end
        end)
    end
end

function BeetleCharge(beetle, x, y, z)
    local ux, uy = GetUnitPosition(slayer)
    local endX, endY = FindIntersection(x, y, ux, uy)
    local points = GetPointsOnLine(x, y, endX, endY, 15)

    local markers = GetPointsOnLine(x, y, endX, endY, 120)
    local mrkrs = {}

    local angle = CalculateAngle(x, y, endX, endY)

    BlzSetSpecialEffectYaw(beetle, angle)

    for n = 1, #markers do
        local marker = AddSpecialEffect("models\\redtriangle3", markers[n].x, markers[n].y)
        BlzSetSpecialEffectYaw( marker, angle )
        table.insert(mrkrs, marker)
    end

    local i = 1
    local sharp = #points
    local counter = 1
    local index = 1
    local t = CreateTimer()
    TimerStart(t, 1/64, true, function()
        local p = points[i]
        BlzSetSpecialEffectPosition(beetle, p.x, p.y, z)
        if CheckBeetleDamage(p.x, p.y) then
            if not beetleAtached then
                BlzSetSpecialEffectPosition(beetle, 6000, 6000, 0)
                beetleAtached = true
                DestroyEffect(beetle)
                beetleAttach = AddSpecialEffectTarget("models\\beetle150", slayer, "chest")
                BeetlePeriodic()

                local frameTimer = CreateTimer()
                BlzDestroyFrame(beetleFrame)
                beetleFrame = BeetleFrame()
                local pos = 1.1
                BlzFrameSetVisible(beetleFrame, true)
                TimerStart(frameTimer, 1/32, true, function()
                    pos = pos - 0.02
                    BlzFrameSetAbsPoint(beetleFrame, FRAMEPOINT_CENTER, pos, 0.03)
                    if pos <= 0.87 then
                        DestroyTimer(frameTimer)
                    end
                end)

                for k = 1, #mrkrs do
                    DestroyEffect(mrkrs[k])
                end
                DestroyTimer(t)
            else
                for k = 1, #mrkrs do
                    DestroyEffect(mrkrs[k])
                end
                DestroyEffect(beetle)
                DestroyTimer(t)
            end
        end
        counter = counter + 1
        if math.fmod(counter, 8) == 0 then
            DestroyEffect(mrkrs[index])
            index = index + 1
        end
        i = i + 1
        if i > sharp then
            DestroyEffect(beetle)
            for k = 1, #mrkrs do
                DestroyEffect(mrkrs[k])
            end
            DestroyTimer(t)
        end


    end)
end

function BeetleFrame()
    local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
    BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 1.1, 0.03)
    BlzFrameSetSize(spriteframe, 0.001, 0.001)
    BlzFrameSetScale(spriteframe, 1)
    BlzFrameSetLevel(spriteframe, 3)
    BlzFrameSetModel(spriteframe, "sprites\\beetleSprite2", 1)
    BlzFrameSetSpriteAnimate(spriteframe, 2, 2)
    BlzFrameSetVisible(spriteframe, false)

    return spriteframe
end

function DestroyBeetleFrame()
    local frameTimer = CreateTimer()
    local pos = 0.87
    BlzFrameSetVisible(beetleFrame, true)
    TimerStart(frameTimer, 1/32, true, function()
        if beetleAtached then
            DestroyTimer(frameTimer)
        end
        pos = pos + 0.02
        BlzFrameSetAbsPoint(beetleFrame, FRAMEPOINT_CENTER, pos, 0.03)
        if pos >= 1.1 then
            BlzDestroyFrame(beetleFrame)
            beetleFrame = nil
            DestroyTimer(frameTimer)
        end
    end)
    --print("beetlframedestroy")
end



function Cage(radius, duration)
    local x, y = GetUnitPosition(slayer)
    if IsPointInCircle(x, y, CenterX, CenterY, Radius) then
        local effects = {}
        hexPoints = GetHexagonPoints(x, y, radius, radius/2.5)
        local pointsChain = GetHexagonPoints(x, y, radius, 40)
        --print(#hexPoints)
        local d = 1
        local sharp = #pointsChain
        local chainTimer = CreateTimer()
        PlayCage()
        TimerStart(chainTimer, 1/64, true, function()
            local p1 = pointsChain[d]
            local chain = AddSpecialEffect("models\\chainlink2", p1.x, p1.y )
            if d < #pointsChain then
                local angleChain = CalculateAngle(p1.x, p1.y, pointsChain[d+1].x, pointsChain[d+1].y)
                BlzSetSpecialEffectYaw(chain, angleChain)
                BlzSetSpecialEffectScale(chain, 1.15)
                table.insert(effects, chain)
            else
                local angleChain = CalculateAngle(p1.x, p1.y, pointsChain[1].x, pointsChain[1].y)
                BlzSetSpecialEffectYaw(chain, angleChain)
                BlzSetSpecialEffectScale(chain, 1.1)
                table.insert(effects, chain)
            end
            d = d + 1
            if d > sharp then
                for i = 1, #hexPoints do
                    local p = hexPoints[i]
                    local eff = AddSpecialEffect("models\\skeleton", p.x, p.y)
                    local angle = CalculateAngle(p.x, p.y, x, y)
                    BlzSetSpecialEffectYaw(eff, angle)
                    table.insert(effects, eff)
                end
                CageOn = true
                ------------
                local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
                BlzFrameSetVisible(Mask, false)
                BlzFrameSetLevel(Mask,4)
                BlzFrameSetAbsPoint(Mask, FRAMEPOINT_CENTER, 0.8, 0.08)
                BlzFrameSetSize(Mask, 0.4, 0.23)
                BlzFrameSetTexture(Mask, "backdrops\\chain1", 0, true)
                BlzFrameSetAlpha(Mask, 255)

                local Mask1 = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
                BlzFrameSetVisible(Mask1, false)
                BlzFrameSetLevel(Mask1,4)
                BlzFrameSetAbsPoint(Mask1, FRAMEPOINT_CENTER, -0.05, 0.52)
                BlzFrameSetSize(Mask1, 0.4, 0.23)
                BlzFrameSetTexture(Mask1, "backdrops\\chain1", 0, true)
                BlzFrameSetAlpha(Mask1, 255)
                ------------

                local spriteframe = CageFrame()
                if IsPointInHexagon(GetUnitX(slayer), GetUnitY(slayer), hexPoints) then
                    BlzFrameSetVisible(spriteframe, true)
                    BlzFrameSetVisible(Mask1, true)
                    BlzFrameSetVisible(Mask, true)
                    SlayerInsideCage = true
                    local frameTimer = CreateTimer()
                    local pos = 1.1
                    TimerStart(frameTimer, 1/32, true, function()
                        pos = pos - 0.02
                        BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, pos, -0.036)
                        if pos <= 0.82 then
                            DestroyTimer(frameTimer)
                        end
                    end)
                end
                local cageTimer = CreateTimer()
                TimerStart(cageTimer, duration, false, function()
                    for e = 1, #effects do
                        DestroyEffect(effects[e])
                    end

                    CageOn = false
                    if SlayerInsideCage then
                        local frameTimer1 = CreateTimer()
                        local pos = 0.82
                        local alpha = 255
                        TimerStart(frameTimer1, 1/32, true, function()
                            pos = pos + 0.02
                            BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, pos, -0.036)

                            alpha = alpha - 17
                            BlzFrameSetAlpha(Mask1, alpha)
                            BlzFrameSetAlpha(Mask, alpha)
                            if pos >= 1.1 then
                                BlzDestroyFrame(spriteframe)
                                BlzDestroyFrame(Mask)
                                BlzDestroyFrame(Mask1)
                                DestroyTimer(frameTimer1)
                            end
                        end)
                    end
                    SlayerInsideCage = false
                    hexPoints = {}
                    DestroyTimer(cageTimer)
                end)
                DestroyTimer(chainTimer)
            end
        end)
    end
end

function CageFrame()
    local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)
    BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 1.1, -0.036)
    BlzFrameSetSize(spriteframe, 0.001, 0.001)
    BlzFrameSetScale(spriteframe, 1)
    BlzFrameSetLevel(spriteframe, 3)
    BlzFrameSetModel(spriteframe, "models\\skeletonsprite2", 1)
    BlzFrameSetSpriteAnimate(spriteframe, 2, 2)
    BlzFrameSetVisible(spriteframe, false)

    return spriteframe
end
function Bugs()
    carouselCounter = 0
    local x1, y1 = GetRandomPointOnCircle(CenterX, CenterY, Radius)
    local x2, y2 = GetOppositePointOnCircle(CenterX, CenterY, x1, y1)

    local x3, y3, x4, y4 = GetPerpendicularDiameter(Radius, x1, y1, x2, y2)
    BugLine(x1, y1, x2, y2)
    BugLine(x3, y3, x4, y4)
    castCarousel = true
end

function BugLine(x1, y1, x2, y2)
    local diameterPoints = GetPointsOnLine(x1, y1, x2, y2, 160)
    for n = #diameterPoints, 1, -1 do
        if IsPointInCircle(diameterPoints[n].x, diameterPoints[n].y, GetUnitX(boss), GetUnitY(boss), 20) then
            table.remove(diameterPoints, n)
            --print("wrong bug")
        end
    end
    table.insert(diameterPoints, 1, {x = x1, y = y1})
    local angle = CalculateAngle(x1, y1, x2, y2)
    local effects = {}
    for a = 1, #diameterPoints do
        local eff = AddSpecialEffect("models\\bug", diameterPoints[a].x, diameterPoints[a].y)
        if a <= #diameterPoints/2 then
            BlzSetSpecialEffectYaw(eff, angle + math.pi/2)
        else
            BlzSetSpecialEffectYaw(eff, angle - math.pi/2)
        end
        local t = CreateTimer()
        TimerStart(t, 1, false, function()
            BlzPlaySpecialEffect(eff, ANIM_TYPE_WALK)
            DestroyTimer(t)
        end)
        table.insert(effects, eff)
    end

    local newAngle = 0
    local tim = CreateTimer()
    local double = 1 --надо нормально задавать количество поворотов
    TimerStart(tim, 1/32, true, function()
        local points = RotateDiameter(diameterPoints, CenterX, CenterY, newAngle * math.pi/180)
        local yaw = CalculateAngle(points[1].x, points[1].y, points[#points].x, points[#points].y)
        for i = 1, #effects do
            local p = points[i]
            BlzSetSpecialEffectPosition(effects[i], p.x, p.y, 320)
            BlzSetSpecialEffectScale(effects[i], 2)
            CheckBugsDamage(p.x, p.y)
            if i <= #diameterPoints/2 then
                BlzSetSpecialEffectYaw(effects[i], yaw + math.pi/2)
            else
                BlzSetSpecialEffectYaw(effects[i], yaw -  math.pi/2)
            end

        end
        newAngle = newAngle + 1.5
        if newAngle > 360 and double == 1 then
            newAngle = 0
            double = 2
        elseif newAngle > 180 and double == 2 then --сделает полтора оборота
            for b = 1, #effects do
                DestroyEffect(effects[b])
                castCarousel = false
                DestroyTimer(tim)
            end
        end
    end)
end
function CorpseBombs(bombs, time)
    local x, y = GetUnitPosition(slayer)
    CorpseBomb(x, y)
    local t = CreateTimer()
    local i = 0
    TimerStart(t, time, true, function()
        local x, y = GetUnitPosition(slayer)
        --local endP = RandomPointInCircle(x, y, 600)
        CorpseBomb(x, y)
        --CorpseBomb(endP[1], endP[2])
        i = i + 1
        if i >= bombs-1 then
            castCorpse = false
            DestroyTimer(t)
        end
    end)

end

function CorpseBomb(targetX, targetY)
    if IsPointInCircle(targetX, targetY, CenterX, CenterY, Radius) then
        local startX, startY = GetUnitPosition(boss)
        local endX, endY = GetRandomPointOnCircle(GetUnitX(slayer), GetUnitY(slayer), 600)
        local maxZ = 1200
        local startZ = 400
        local endZ = 353

        local points = ComputePathWithRotation(startX, startY, startZ, targetX, targetY, endZ, maxZ, 50)
        local t = CreateTimer()
        local i = 1
        local sharp = #points
        local eff = AddSpecialEffect("models\\MeatWagon", startX, startY)
        BlzSetSpecialEffectScale(eff, 0.75)
        local marker = AddSpecialEffect("models\\marker", targetX, targetY)
        BlzSetSpecialEffectScale(marker, 1.5)
        TimerStart(t, 1/32, true, function()
            local p = points[i]
            BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
            BlzSetSpecialEffectOrientation(eff, p.yaw, p.pitch, p.roll)

            i = i + 1
            if i > sharp then
                --BlzSetSpecialEffectOrientation(eff, 0, 0, 0)
                DestroyEffect(eff)
                local boom = AddSpecialEffect("Abilities\\Weapons\\FireBallMissile\\FireBallMissile", p.x, p.y)
                BlzSetSpecialEffectScale(boom, 2)
                DestroyEffect(boom)
                DestroyEffect(marker)
                BlzSetSpecialEffectRoll(eff, 0)
                BlzSetSpecialEffectPitch(eff, 0)
                CorpseFireworks(p.x, p.y, math.random(12, 24))
                CheckCorpseBombDamage(p.x, p.y)
                DestroyTimer(t)
            end
        end)
    end
end

function CorpseFireworks(x, y, numb)
    for i = 1, numb do
        local eff = AddSpecialEffect("Abilities\\Weapons\\MeatwagonMissile\\MeatwagonMissile", x, y)
        BlzSetSpecialEffectScale(eff, 1.11)
        local endP = RandomPointInCircle(x, y, 550)
        local marker = AddSpecialEffect("models\\marker", endP[1], endP[2])
        local maxZ = 820
        local startZ = 400
        local endZ = 320
        local points = ComputePath(x, y, startZ, endP[1], endP[2], endZ, maxZ, 20)

        local i = 1
        local sharp = #points
        local t = CreateTimer()
        TimerStart(t, 1/32, true, function()
            local p = points[i]
            BlzSetSpecialEffectPosition(eff, p.x, p.y, p.z)
            i = i + 1
            if i > sharp then
                PauseTimer(t)
                DestroyEffect(eff)
                DestroyEffect(marker)
                CheckCorpseFireworksDamage(p.x, p.y)
                DestroyTimer(t)
            end
        end)
    end
end
function CreateBoss()
    boss = CreateUnit(Player(1), _('Uanb'), 0, 0, bj_UNIT_FACING)
    SetHeroLevel(boss, 10, false)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitInvulnerable(boss, true)
    --print("works")
    Invulnerable(true)
end





function Invulnerable(flag)
    if flag then
        SetUnitColor(boss, PLAYER_COLOR_RED)
        BlzFrameSetModel(bar, "sprites\\testbar.mdx", 0)
        SetUnitInvulnerable(boss, true)
        local sX, sY = GetUnitPosition(slayer)
        local x, y = GetUnitPosition(boss)
        local angle = CalculateAngle(x, y, sX, sY)
        --SetUnitFacing(boss, angle*180 / math.pi)
        SetUnitAnimation(boss, "stand")
        BlzFrameSetVisible(invul, true)
    else
        SetUnitColor(boss, PLAYER_COLOR_GREEN)
        BlzFrameSetModel(bar, "sprites\\testbar1.mdx", 0)
        SetUnitInvulnerable(boss, false)
        local sX, sY = GetUnitPosition(slayer)
        local x, y = GetUnitPosition(boss)
        local angle = CalculateAngle(x, y, sX, sY)
        --SetUnitFacing(boss, angle *180 / math.pi)
        SetUnitAnimation(boss, "stand")
        BlzFrameSetVisible(invul, false)
    end
end






function FireBall(startX, startY, endX, endY)
    --local angle = CalculateAngle(startX, endX, GetUnitX(slayer), GetUnitY(slayer))
    if IsPointInCircle(endX, endY, CenterX, CenterY, Radius) then
        --SetUnitFacing(boss, angle*180 / math.pi)
        SetUnitAnimationByIndex(boss, 7)
        local marker = AddSpecialEffect("models\\marker", endX, endY)
        BlzSetSpecialEffectScale(marker, 0.8)
        local maxZ = 820
        local startZ = 400
        local endZ = 220

        local points = ComputePath(startX, startY, startZ, endX, endY, endZ, maxZ, 30)
        local eff = AddSpecialEffect("Abilities\\Weapons\\FireBallMissile\\FireBallMissile", startX, startY)
        BlzSetSpecialEffectScale(eff, 1.5)
        local t = CreateTimer()
        local i = 1
        local sharp = #points

        TimerStart(t, 1/32, true, function()
            BlzSetSpecialEffectX(eff, points[i].x)
            BlzSetSpecialEffectY(eff, points[i].y)
            BlzSetSpecialEffectZ(eff, points[i].z)
            i = i + 1
            if i >= sharp then
                PauseTimer(t)
                CheckFireballDamage(points[i].x, points[i].y)
                DestroyEffect(marker)
                DestroyEffect(eff)
                DestroyTimer(t)
            end
        end)
    end
end

function FireBalls(time, bigCircleValue, littleCircleValue)
    --local time = 0.15
    --local bigCircleValue = 10
    --local littleCircleValue = 20


    local startX, startY = GetUnitPosition(boss)
    local endX, endY = GetUnitPosition(slayer)

    local targets = {}
    table.insert(targets, {endX, endY})

    for i = 1, littleCircleValue do
        table.insert(targets, RandomPointInCircle(endX, endY, 425))
    end
    for ii = 1, bigCircleValue do
        table.insert(targets, RandomPointInCircle(CenterX, CenterY, Radius))
    end
    local t = CreateTimer()
    local a = 1
    TimerStart(t, time, true, function()
        FireBall(startX, startY, targets[a][1], targets[a][2])
        a=a+1
        if a > #targets then
            PauseTimer(t)
            DestroyTimer(t)
        end
    end)
end
function ThrowStone()
    local bx, by = GetUnitPosition(boss)
    local sx, sy = RandomPointInCircleXY(GetUnitX(slayer), GetUnitY(slayer), 400)
    local targetX, targetY = FindIntersection(bx, by, sx, sy)
    local points = GetPointsOnLineWithRotation(bx, by, targetX, targetY, 50)
    local eff = AddSpecialEffect("models\\Rock3", bx, by)
    BlzSetSpecialEffectScale(eff, 0.75)
    BlzSetSpecialEffectZ(eff, 350)


    local t = CreateTimer()
    local i = 1
    local sharp = #points
    TimerStart(t, 1/32, true, function()
        local pt = points[i]
        BlzSetSpecialEffectPosition(eff, pt.x,pt.y, 350)
        if CheckStoneDamage(pt.x, pt.y) then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSound()
            DestroyTimer(t)
        end
        --BlzSetSpecialEffectYaw(eff, pt.yaw)
        --BlzSetSpecialEffectPitch(eff, pt.pitch)
        --BlzSetSpecialEffectRoll(ff, pt.roll)
        BlzSetSpecialEffectOrientation(eff, pt.yaw, pt.pitch, pt.roll)
        i = i + 1
        if i > sharp then
            PauseTimer(t)
            DestroyEffect(eff)
            PlayStoneSoundMain(pt.x, pt.y)
            DestroyTimer(t)
        end
    end)
end

function ThrowStones(duration)
    local points = RotatePoints(GetUnitX(boss), GetUnitY(boss), 200, 5)
    local t = {}
    for i = 1, 4 do
        local eff = AddSpecialEffect("models\\Rock3", points[i][1][1], points[i][1][2])
        BlzSetSpecialEffectScale(eff, 0.75)
        BlzSetSpecialEffectYaw(eff, math.random(1, 3))
        BlzSetSpecialEffectZ(eff, 350)
        table.insert(t, eff)
    end
    local rotateTimer = CreateTimer()
    local cd = CreateTimer()
    local waitDuration = CreateTimer()


    local n = 1
    local sharp = #points[1]
    TimerStart(rotateTimer, 1/32, true, function()
        for a = 1, 4 do
            BlzSetSpecialEffectPosition(t[a], points[a][n][1], points[a][n][2], 350)
        end
        if n == sharp then
            n = 2
        else
            n=n+1
        end
    end)
    TimerStart(cd, 0.5, true, function()
        ThrowStone()
    end)
    TimerStart(waitDuration, duration, false, function()
        PauseTimer(cd)
        DestroyTimer(cd)
        PauseTimer(rotateTimer)
        DestroyTimer(rotateTimer)
        for m = 1, #t do
            DestroyEffect(t[m])
        end
        castRocks = false --!!!!!
        DestroyTimer(waitDuration)
    end)
end
function TripleImpale(d)
    --print("triple impale")

    local targetX, targetY = GetUnitPosition(slayer)
    if IsPointInCircle(targetX, targetY, CenterX, CenterY, Radius) then
        local target1 = {targetX, targetY}

        local casterX, casterY = GetUnitPosition(boss)
        local casterX, casterY = GetPointOnLine(casterX, casterY, targetX, targetY, 80)


        local angle, distance = CalculateAngleAndDistance(casterX, casterY, targetX, targetY)
        SetUnitFacing(boss, angle*180 / math.pi)
        SetUnitAnimationByIndex(boss, 7)

        local leftAngle = angle + math.rad(d)
        local rightAngle = angle - math.rad(d)

        local target1X = casterX + distance * math.cos(leftAngle)
        local target1Y = casterY + distance * math.sin(leftAngle)
        local target2 = {target1X, target1Y}

        local target2X = casterX + distance * math.cos(rightAngle)
        local target2Y = casterY + distance * math.sin(rightAngle)
        local target3 = {target2X, target2Y}

        local targets = {target1, target2, target3}
        local angles = {angle, leftAngle, rightAngle}
        local points = {}
        local endpoints = {}

        for i = 1, #impaleCasters do
            local endpointX, endpointY = FindIntersection(casterX, casterY, targets[i][1], targets[i][2])
            table.insert(endpoints, i, {endpointX, endpointY})
            local trueDistance = CalculateDistance(casterX, casterY, endpointX, endpointY)
            local impspll = BlzGetUnitAbility(impaleCasters[i], _('AUim'))
            BlzSetAbilityRealLevelField(impspll, ABILITY_RLF_WAVE_DISTANCE, 0, trueDistance)
            SetUnitPositionWithFacing(impaleCasters[i], casterX, casterY, angles[i])
            local linePoints = GetPointsOnLine(casterX, casterY, endpointX, endpointY, 100)
            table.insert(points, i, linePoints)


        end
        --print(GetUnitPosition(impaleCasters[1]))

        local effects = {}
        local iTable = {1, 1, 1}
        for l = 1, 3 do
            TimerStart( CreateTimer(), 1/#points[l], true, function()
                eff = AddSpecialEffect("models\\redtriangle3", points[l][iTable[l]].x, points[l][iTable[l]].y)
                BlzSetSpecialEffectYaw( eff, angles[l] )
                PlayImpaleMarkerSound(points[l][iTable[l]].x, points[l][iTable[l]].y)
                table.insert(effects, eff)
                iTable[l] = iTable[l] + 1
                if iTable[l] == #points[l] then
                    PauseTimer(GetExpiredTimer())
                    DestroyTimer(GetExpiredTimer())
                end
            end)
        end

        local castDelay = CreateTimer()
        TimerStart(castDelay, 0.75, false, function()


            IssuePointOrder(dummy1, "impale", endpoints[1][1], endpoints[1][2])

            IssuePointOrder(dummy2, "impale", endpoints[2][1], endpoints[2][2])

            IssuePointOrder(dummy3, "impale", endpoints[3][1], endpoints[3][2])


            local t1 = CreateTimer()
            TimerStart(t1, 0.4, false, function()
                CameraSetEQNoiseForPlayer( Player(0), 30.00 )
                PlayImpaleSound()
                DestroyTimer(t1)
            end)

            local t2 = CreateTimer()
            TimerStart(t2, 0.65, false, function()
                CameraClearNoiseForPlayer( Player(0) )
                --print(#effects)
                for e = 1, #effects do
                    DestroyEffect(effects[e])
                end
                DestroyTimer(t2)
            end)

            local t = CreateTimer()
            TimerStart(t, 0.75, false, function()
                for i = 1, 3 do
                    SetUnitPosition(impaleCasters[i], -1500, -1500)
                end
                DestroyTimer(t)
            end)
            DestroyTimer(castDelay)
        end)
    end
end
function ChainHook()
    if chainCharges > 0 then
        if chainMarker and not Chaining  then --and not chaincooldown
            chainMarker = false
            local function MoveToTheTarget(points, effects, sharp, unittarget)
                local i = 1
                local t2 = CreateTimer()
                TimerStart( t2, 1/64, true, function()
                    p = points[i]
                    DestroyEffect(effects[i])
                    if IsPointInCircle(p.x, p.y, CenterX, CenterY, Radius) then
                        if not CageOn then --блок для проверки на границы костяной тюрьмы, нужно вынести в отдельную функцию
                            SetUnitPosition(slayer, p.x, p.y)
                            --SetUnitPathing(slayer, false)
                            FixCursor(p.x, p.y)
                        elseif SlayerInsideCage then
                            local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                            if not IsPointInHexagon(xx, yy, hexPoints) then
                                for e = 1, #effects do
                                    DestroyEffect(effects[e])
                                end
                                IssueImmediateOrder(slayer, "stop")
                                EnableTrigger(ClickTrigger)
                                SetUnitInvulnerable(slayer, false)
                                InitWalkTimer()
                                --PauseUnit(slayer, false)
                                SetUnitMoveSpeed(slayer, 522)
                                Chaining = false
                                SetUnitMoveSpeed(unittarget, 75)
                                DestroyTimer(t2)
                            else
                                SetUnitPosition(slayer, p.x, p.y)
                                FixCursor(p.x, p.y)
                            end
                        else
                            local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 80)
                            if IsPointInHexagon(xx, yy, hexPoints) then
                                for e = 1, #effects do
                                    DestroyEffect(effects[e])
                                end
                                IssueImmediateOrder(slayer, "stop")
                                EnableTrigger(ClickTrigger)
                                SetUnitInvulnerable(slayer, false)
                                InitWalkTimer()
                                --PauseUnit(slayer, false)
                                SetUnitMoveSpeed(slayer, 522)
                                Chaining = false
                                DestroyTimer(t2)
                            else
                                SetUnitPosition(slayer, p.x, p.y)
                                FixCursor(p.x, p.y)
                            end
                        end
                    end
                    i = i + 1
                    if i > sharp - 8 then
                        Chaining = false
                    end
                    if i > sharp then
                        PauseTimer(t2)
                        EnableTrigger(ClickTrigger)
                        SetUnitInvulnerable(slayer, false)
                        InitWalkTimer()
                        --PauseUnit(slayer, false)
                        SetUnitMoveSpeed(slayer, 522)
                        Chaining = false
                        --local pathingTimer = CreateTimer()
                        --TimerStart(pathingTimer, 2, false, function()
                            --SetUnitPathing(slayer, true)
                           -- DestroyTimer(pathingTimer)
                        --end)
                        DestroyTimer(t2)
                    end
                end)
            end

            local targets = {}
            local cursorX = BlzGetTriggerPlayerMouseX()
            local cursorY = BlzGetTriggerPlayerMouseY()
            if IsPointInCircle(cursorX, cursorY, CenterX, CenterY, Radius) then
                local x, y = GetUnitPosition(slayer)


                local target = FindClosestUnit(chainTargets, cursorX, cursorY)
                local tX, tY = GetUnitPosition(target)

                if IsPointInCircle(x, y, CenterX, CenterY, Radius) and IsPointInCircle(tX, tY, x, y, 870) and IsPointInCircle(tX, tY, cursorX, cursorY, 150) then
                    IssueImmediateOrder(target, "stop")
                    SetUnitMoveSpeed(target, 0)
                    Chaining = true
                    --chaincooldown = true
                    chainCharges = chainCharges - 1
                    if chainCharges <= 0 then
                        SetIconEnable(iconsUI[4], false)
                    end
                    UpdateCharges(4, chainCharges)
                    DisplayCooldown(true)
                    --local cdtimer = CreateTimer()
                    --TimerStart(cdtimer, 2, false, function()
                        --chaincooldown = false
                        --DestroyTimer(cdtimer)
                    --end)
                    DisableTrigger(ClickTrigger)
                    DestroyTimer(walkTimer)
                    SetUnitInvulnerable(slayer, true)
                    PlayChain()
                    --PauseUnit(slayer, true)
                    SetUnitMoveSpeed(slayer, 0)
                    IssueImmediateOrder(slayer, "stop")
                    local x1, y1 = GetPointOnLine(tX, tY, x, y, 36)
                    local points = GetPointsOnLine(x, y, x1, y1, 34)
                    table.remove(points, #points)
                    local i = 1
                    local sharp = #points
                    local angle = CalculateAngle(x, y, x1, y1)
                    local t = CreateTimer()
                    local effects = {}

                    TimerStart( t, 1/64, true, function()
                        p = points[i]
                        eff = AddSpecialEffect("models\\chainlink1", p.x, p.y)
                        BlzSetSpecialEffectYaw( eff, angle )
                        table.insert(effects, eff)
                        i = i + 1
                        if i > sharp then
                            PauseTimer(t)
                            MoveToTheTarget(points, effects, sharp, target)
                            DestroyTimer(t)
                        end
                    end)
                else
                    PlayBrokenChain()
                end
            end
        end
    end
end

--globalMarkerDistance = 0
function FindChainTarget()
    --print(chainCharges)
    ------fix double circle
    if (not chainMarker) or (not rmbpressed) then
        for b = 1, #slayerEffects do
            DestroyEffect(slayerEffects[b])
        end
        for b = 1, #slayerEffectsRed do
            DestroyEffect(slayerEffectsRed[b])
        end
        for b = 1, #targetEffects do
            DestroyEffect(targetEffects[b])
        end
        slayerEffects = {}
        slayerEffectsRed = {}
        targetEffects = {}
    end
    --------
    if chainMarker == false and chainCharges > 0 then
        for i = 1, 32 do --создали пул эффектов вне зоны видимости
            local eff = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
            BlzSetSpecialEffectScale(eff, 0.5)
            BlzSetSpecialEffectColor(eff, 0, 255, 0)
            table.insert(slayerEffects, eff)
            local effr = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
            BlzSetSpecialEffectScale(effr, 0.5)
            BlzSetSpecialEffectColor(effr, 255, 0, 0)
            table.insert(slayerEffectsRed, effr)
        end

        local effT = AddSpecialEffect("models\\aoe_indicator", -6000, -6000) --models\\greencircle
        BlzSetSpecialEffectColor(effT, 0, 255, 0)
        BlzSetSpecialEffectScale(effT, 2)
        table.insert(targetEffects, effT)
        local effTr = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
        BlzSetSpecialEffectColor(effTr, 255, 0, 0)
        BlzSetSpecialEffectScale(effTr, 2)
        table.insert(targetEffects, 2, effTr)
        local effST = AddSpecialEffect("models\\aoe_indicator", -6000, -6000)
        BlzSetSpecialEffectScale(effST, 11)
        BlzSetSpecialEffectColor(effST, 0, 255, 0)
        table.insert(targetEffects, 3, effST)

        chainMarker = true
        local t = CreateTimer()
        TimerStart(t, 1/32, true, function()
            local ux, uy = GetUnitPosition(slayer)
            local target = FindClosestUnit(chainTargets, globalCursorX, globalCursorY)

            local tX, tY = GetUnitPosition(target)

            BlzSetSpecialEffectPosition(targetEffects[3], ux, uy, 320)


            local mx = BlzGetTriggerPlayerMouseX()
            --print(globalCursorX)
            local points = GetPointsOnLine(ux, uy, tX, tY, 60)
            local thetable = {}
            if IsPointInCircle(tX, tY, globalCursorX, globalCursorY, 150) then
                BlzSetSpecialEffectPosition(targetEffects[2], -6000, -6000, 320)
                BlzSetSpecialEffectPosition(targetEffects[1], tX, tY, 320)
            else
                BlzSetSpecialEffectPosition(targetEffects[1], -6000, -6000, 320)
                BlzSetSpecialEffectPosition(targetEffects[2], tX, tY, 320)
            end
            if IsPointInCircle(ux, uy, CenterX, CenterY, Radius) and IsPointInCircle(tX, tY, ux, uy, 870) then

                for a = 1, #slayerEffectsRed do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], -6000, -6000, 370)
                end

                for a = 1, #points do
                    BlzSetSpecialEffectPosition(slayerEffects[a], points[a].x, points[a].y, 370)
                end

                for a = #points + 1, #slayerEffects do
                    BlzSetSpecialEffectPosition(slayerEffects[a], -6000, -6000, 370)
                end
            else
                if not IsPointInCircle(ux, uy, CenterX, CenterY, Radius) then
                    chainMarker = false
                    for b = 1, #slayerEffects do
                        DestroyEffect(slayerEffects[b])
                    end
                    for b = 1, #slayerEffectsRed do
                        DestroyEffect(slayerEffectsRed[b])
                    end
                    DestroyTimer(t)
                end

                for a = 1, #slayerEffects do
                    BlzSetSpecialEffectPosition(slayerEffects[a], -6000, -6000, 370)
                end

                for a = 1, #points do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], points[a].x, points[a].y, 370)
                end

                for a = #points + 1, #slayerEffectsRed do
                    BlzSetSpecialEffectPosition(slayerEffectsRed[a], -6000, -6000, 370)
                end
            end

            if (not chainMarker) or (not rmbpressed) then
                for b = 1, #slayerEffects do
                    DestroyEffect(slayerEffects[b])
                end
                for b = 1, #slayerEffectsRed do
                    DestroyEffect(slayerEffectsRed[b])
                end
                for b = 1, #targetEffects do
                    DestroyEffect(targetEffects[b])
                end
                slayerEffects = {}
                slayerEffectsRed = {}
                targetEffects = {}
                DestroyTimer(t)
            end
        end)
    elseif chainCharges == 0 then
        PlayBrokenChain()
    end
end
function Dash()
    if dashCharges > 0 then
        local distance = 400

        local mouseX, mouseY = GetUnitPosition(posdummy)

        local slayerX, slayerY = GetUnitPosition(slayer)

        local x, y = GetPointOnLine(slayerX, slayerY, mouseX, mouseY, distance)

        if Stage == 2 and not IsPointInCircle(x, y, CenterX, CenterY, Radius) then
            x, y = FindIntersection(slayerX, slayerY, x, y)
            x, y = GetPointOnLine(x, y, slayerX, slayerY, 50)
        end

        local points = GetPointsOnLine(slayerX, slayerY, x, y, 40)
        local i = 1
        local sharp = #points
        PlayDashSound()
        dashCharges = dashCharges - 1
        if dashCharges <= 2 then
            if dashCharges <= 0 then
                SetIconEnable(iconsUI[2], false)
            end
            local rand = math.random()
            if rand <= 0.20 and #dashChargesItems < 3 then
                CreateCharge()
            end
        end

        UpdateCharges(2, dashCharges)
        DisplayCooldown(true)
        local t = CreateTimer()
        TimerStart(t, 1/64, true, function()
            if (GetUnitAbilityLevel(slayer, _('BUim')) == 0) then
                local p = points[i]

                if fuelOnMap then
                    local sharpF = #fuel
                    for f = 1, sharpF do
                        local fuelX = fuel[f][1][1]
                        local fuelY = fuel[f][1][2]
                        if IsPointInCircle(p.x, p.y, fuelX, fuelY , 80) then
                            --print(fuelX)
                            PickFuel(fuel[f], f)
                            break
                        end
                    end
                end
                if chargesOnMap then
                    local sharpC = #dashChargesItems
                    for c = 1, sharpC do
                        local chargeX = dashChargesItems[c][1][1]
                        local chargeY = dashChargesItems[c][1][2]
                        if IsPointInCircle(p.x, p.y, chargeX, chargeY , 80) then
                            --print(chargeX)
                            PickCharge(dashChargesItems[c], c)
                            break
                        end
                    end
                end

                if not CageOn then
                    local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                    DestroyEffect(eff)
                    SetUnitPosition(slayer, p.x, p.y)
                    SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                    FixCursor(p.x, p.y)
                    i = i + 1
                    if i > sharp then
                        DestroyTimer(t)
                    end
                elseif SlayerInsideCage then
                    local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                    if not IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                        DestroyTimer(t)
                    else
                        local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                        DestroyEffect(eff)
                        SetUnitPosition(slayer, p.x, p.y)
                        SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                        FixCursor(p.x, p.y)
                        i = i + 1
                        if i > sharp then
                            DestroyTimer(t)
                        end
                    end
                else
                    local xx, yy = GetPointOnLine(p.x, p.y, points[sharp].x, points[sharp].y, 20)
                    if IsPointInHexagon(xx, yy, hexPoints) then
                        IssueImmediateOrder(slayer, "stop")
                        DestroyTimer(t)
                    else
                        local eff = AddSpecialEffect("models\\riflemanTrack", p.x, p.y)
                        DestroyEffect(eff)
                        SetUnitPosition(slayer, p.x, p.y)
                        SetUnitPosition(posdummy, p.x + (mouseX - slayerX), p.y + (mouseY - slayerY))
                        FixCursor(p.x, p.y)
                        i = i + 1
                        if i > sharp then
                            DestroyTimer(t)
                        end
                    end
                end
            else
                DestroyTimer(t)
            end
        end)
    else
        PlayError()
    end
end


function CreateCharge()
    local xy = RandomPointInCircle(CenterX, CenterY, Radius-50)
    local eff = AddSpecialEffect("units\\nightelf\\Wisp\\Wisp", xy[1], xy[2])
    BlzSetSpecialEffectColorByPlayer(eff, Player(6))
    table.insert(dashChargesItems, {xy, eff})
    chargesOnMap = true
end



function PickCharge(chargeEff, index)
    --без проверки, просто добавить заряд

    DestroyEffect(chargeEff[2])
    table.remove(dashChargesItems, index)
    dashCharges = dashCharges + 1
    SetIconEnable(iconsUI[2], true)
    UpdateCharges(2, dashCharges)

    if #dashChargesItems == 0 then
        chargesOnMap = false
    end
end

function MakeShot(x, y)
    local startx, starty = GetUnitPosition(slayer)
    if IsPointInCircle(startx, starty, CenterX, CenterY, Radius - 20) then
        if rocketCharges > 0 then --not cooldown
            if not beetleAtached then
                --cooldown = true
                --local cooldownTimer = CreateTimer()
                --TimerStart(cooldownTimer, 0.2, false, function()
                --cooldown = false
                --end)
                local projectile = AddSpecialEffect("Abilities\\Weapons\\GyroCopter\\GyroCopterMissile", startx, starty)


                local targetx = BlzGetTriggerPlayerMouseX()
                local targety = BlzGetTriggerPlayerMouseY()

                local angle, distance = CalculateAngle(startx, starty, targetx, targety)
                BlzSetSpecialEffectYaw( projectile, angle )
                BlzSetSpecialEffectZ(projectile, 350)
                local endpointX, endpointY = FindIntersection(startx, starty, targetx, targety)
                local hitplaceX, hitplaceY = RayCircleIntersection(startx, starty, endpointX, endpointY, GetUnitX(boss), GetUnitY(boss), 120)

                local movePoints = GetPointsOnLine(startx, starty, endpointX, endpointY, 20)
                local sharp = #movePoints
                local i = 1
                local t = CreateTimer()
                if hitplaceX == nill then
                    TimerStart(t, 1/64, true, function()
                        BlzSetSpecialEffectX(projectile, movePoints[i].x)
                        BlzSetSpecialEffectY(projectile, movePoints[i].y)
                        BlzSetSpecialEffectZ(projectile, 350)

                        for a = 1, #creeps do
                            local testX, testY = GetUnitPosition(creeps[a])
                            if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                                PauseTimer(t)
                                DestroyEffect(projectile)
                                ControlDmg(creeps[a])
                                DestroyTimer(t)
                            end
                        end
                        i = i+1
                        if i > sharp then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            DestroyTimer(t)
                        end
                    end)
                else --снаряд попадёт в босса
                    TimerStart(t, 1/64, true, function()
                        BlzSetSpecialEffectX(projectile, movePoints[i].x)
                        BlzSetSpecialEffectY(projectile, movePoints[i].y)
                        BlzSetSpecialEffectZ(projectile, 350)
                        local d = CalculateDistance(movePoints[i].x, movePoints[i].y, hitplaceX, hitplaceY)
                        local testX, testY = GetUnitPosition(testUnit)
                        for a = 1, #creeps do
                            local testX, testY = GetUnitPosition(creeps[a])
                            if IsPointInCircle(movePoints[i].x, movePoints[i].y, testX, testY, 40) then
                                PauseTimer(t)
                                DestroyEffect(projectile)
                                ControlDmg(creeps[a])
                                DestroyTimer(t)
                            end
                        end
                        if d <= 10 then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            ControlBossDamage()
                            DestroyTimer(t)
                        end
                        i = i+1
                        if i > sharp then
                            PauseTimer(t)
                            DestroyEffect(projectile)
                            DestroyTimer(t)
                        end
                    end)
                end
            else
                local projectile = AddSpecialEffect("Abilities\\Weapons\\GyroCopter\\GyroCopterMissile", startx, starty)
                DestroyEffect(projectile)
                beetleHP = beetleHP - 1
                --print(beetleHP)
                if beetleHP <= 0 then
                    DestroyEffect(beetleAttach)
                    DestroyBeetleFrame()
                    --beetleAttach = nil
                    beetleAtached = false
                    beetleHP = 3
                end
            end
            rocketCharges = rocketCharges - 1
            if rocketCharges <= 0 then
                SetIconEnable(iconsUI[1], false)
            end
            UpdateCharges(1, rocketCharges)
        else
            PlayError()
        end

        if rocketCharges <= 40 then
            if not lowAmmo then
                lowAmmo = true
                DisplayWarningAmmo()
            end
        elseif rocketCharges > 40 and lowAmmo then
            lowAmmo = false
        end

        if (lowAmmo or sawingCharges <= 2) then
            if #fuel < 6 then
                local chance = math.random()
                if chance <= 0.08 then
                    SpawnFuel()
                end
            end
            if rocketCharges <= 0 and sawingCharges <= 0 and not fuelOnMap then
                SpawnFuel()
            end
        end
    end
end


function Sawing()
    local targets = {}
    local x, y = GetUnitPosition(slayer)

    local target = FindClosestUnit(creeps, x, y)
    local tX, tY = GetUnitPosition(target)
    if sawingCharges > 0 then
        if IsPointInCircle(tX, tY, x, y, 350) and not Chaining and not dashing and not sawing then
            if (not CageOn) or (CageOn and SlayerInsideCage and IsPointInHexagon(tX, tY, hexPoints)) or (CageOn and not SlayerInsideCage and not IsPointInHexagon(tX, tY, hexPoints)) then
                IssueImmediateOrder(target, "stop")
                SetUnitMoveSpeed(target, 0)
                sawing = true
                sawingCharges = sawingCharges - 1
                if sawingCharges <= 0 then
                    SetIconEnable(iconsUI[3], false)
                end
                UpdateCharges(3, sawingCharges)
                SetUnitPosition(slayer, tX, tY)
                SetUnitInvulnerable(slayer, true)
                CameraSetFocalDistance(50)
                local spriteframe = BlzCreateFrameByType("SPRITE", "SpriteName", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 0)

                PlaySawFleshSound()
                PlayScream()
                BlzFrameSetAbsPoint(spriteframe, FRAMEPOINT_CENTER, 0.4, 0.3)
                BlzFrameSetLevel(spriteframe, 3)
                BlzFrameSetModel(spriteframe, "acowtf4", 0)
                BlzFrameSetSpriteAnimate(spriteframe, 0, 0)
                -- birth = 0
                -- death = 1
                -- stand = 2
                -- morph = 3
                -- alternate = 4
                CinematicFilterGenericBJ( 0.00, BLEND_MODE_BLEND, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 100, 100, 100, 25.00, 100.00, 100.00, 100.00, 25.00 )
                BlzFrameSetAlpha(invul, 200)
                BlzFrameSetVisible(spriteframe, true)
                local Mask = BlzCreateFrameByType("BACKDROP", "Mask", BlzGetFrameByName("ConsoleUIBackdrop", 0), "", 1)
                BlzFrameSetLevel(Mask,4)
                BlzFrameSetAbsPoint(Mask, FRAMEPOINT_TOPLEFT, -0.14, 0.6)
                BlzFrameSetAbsPoint(Mask, FRAMEPOINT_BOTTOMRIGHT, 0.95, 0.0)
                BlzFrameSetTexture(Mask, "backdrops\\blood2", 0, true)
                BlzFrameSetAlpha(Mask, 0)
                local alpha = 0
                SawingReward()
                TimerStart(CreateTimer(), 1/32, true, function()
                    alpha = alpha + 4
                    if alpha >=255 then
                        BlzFrameSetAlpha(Mask, 255)
                        DestroyTimer(GetExpiredTimer())
                    else
                        BlzFrameSetAlpha(Mask, alpha)
                    end
                end)

                local focal = 50

                TimerStart(CreateTimer(), 3, false, function()
                    BlzDestroyFrame(spriteframe)
                    DisplayCineFilterBJ( false )
                    BlzFrameSetAlpha(invul, 255)
                    TimerStart(CreateTimer(), 1/32, true, function()
                        focal = focal + 10
                        if focal >=500 then
                            CameraSetFocalDistance(0)
                            DestroyTimer(GetExpiredTimer())
                        else
                            CameraSetFocalDistance(focal)
                        end
                    end)
                    TimerStart(CreateTimer(), 1/32, true, function()
                        alpha = alpha - 4
                        if alpha <=0 then
                            BlzFrameSetAlpha(Mask, 0)
                            BlzDestroyFrame(Mask)
                            DestroyTimer(GetExpiredTimer())
                        else
                            BlzFrameSetAlpha(Mask, alpha)
                        end
                    end)
                    SetUnitInvulnerable(slayer, false)
                    sawing = false
                    ExplodeUnitBJ(target)
                    for i, v in ipairs(creeps) do
                        if v == target then
                            table.remove(creeps, i)
                            break
                        end
                    end
                    for i, v in ipairs(chainTargets) do
                        if v == target then
                            table.remove(chainTargets, i)
                            break
                        end
                    end
                    AddCreep()
                    DestroyTimer(GetExpiredTimer())
                end)
            end
        end
    else
        PlayError()
    end
end

function SpawnFuel()
    local xy = RandomPointInCircle(CenterX, CenterY, Radius-50)
    local eff = AddSpecialEffect("models\\fuel", xy[1], xy[2])
    fuelOnMap = true
    table.insert(fuel, {xy, eff})
end

function PickFuel(fuelEff, index)
    if sawingCharges < sawingChargesConst then
        local x = BlzGetLocalSpecialEffectX(fuelEff[2])
        local y = BlzGetLocalSpecialEffectY(fuelEff[2])
        DestroyEffect(fuelEff[2])
        table.remove(fuel, index)
        sawingCharges = sawingCharges + 1
        SetIconEnable(iconsUI[3], true)
        UpdateCharges(3, sawingCharges)

        PlayExplode(x, y)
    end
    if #fuel == 0 then
        fuelOnMap = false
    end
end

function SawingReward()
    local t = CreateTimer()
    local i = 0
    TimerStart(t, 1/16, true, function()
        rocketCharges = rocketCharges + 1
        SetIconEnable(iconsUI[1], true)
        if rocketCharges > 40 then
            lowAmmo = false
        end

        if rocketCharges > rocketChargesConst then
            rocketCharges = rocketChargesConst
        end

        if i % 4 == 0 then
            slayerHP = slayerHP + 1

            if slayerHP > slayerHPConst then
                slayerHP = slayerHPConst
            end

            if slayerHP > 50 then
                lowHealh = false
            end

            BlzFrameSetValue(bar2, slayerHP)
        end


        UpdateCharges(1, rocketCharges)
        i = i + 1
        if i > sawingDefaultReward then
            DestroyTimer(t)
        end
    end)

end
function CreateSlayer()
    slayer = CreateUnit(Player(1), _('hrif'), 0, -500, bj_UNIT_FACING)
    SetUnitPathing(slayer, true)
    --SelectHeroSkill(boss, _('AUim'))
    SetUnitMoveSpeed(slayer, 522)



end






--CUSTOM_CODE
function InitCustomPlayerSlots()
SetPlayerStartLocation(Player(0), 0)
SetPlayerColor(Player(0), ConvertPlayerColor(0))
SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
SetPlayerRaceSelectable(Player(0), true)
SetPlayerController(Player(0), MAP_CONTROL_USER)
end

function InitCustomTeams()
SetPlayerTeam(Player(0), 0)
end

function main()
SetCameraBounds(-5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -5632.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
NewSoundEnvironment("Default")
SetAmbientDaySound("NorthrendDay")
SetAmbientNightSound("NorthrendNight")
SetMapMusic("Music", true, 0)
InitBlizzard()
InitGlobals()
end

function config()
SetMapName("TRIGSTR_001")
SetMapDescription("")
SetPlayers(1)
SetTeams(1)
SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
DefineStartLocation(0, 0.0, 0.0)
InitCustomPlayerSlots()
SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
InitGenericPlayerSlots()
end

